#数据结构课设报告

***班级***：<u>1621102</u>

***学号***：<u>072110112</u>

***姓名***：<u>冉中益</u>

***指导老师***：<u>高航</u>

[TOC]

## 必做题

### 菜鸟管理系统

#### 数据结构

```C++
const int MAX_PERSON = 30;

//包裹类
class package{
public:
    int timeAlreadySaved;//已存放的日期
    int size;//类型 小1、中2、大3
    int code;//编号
    string getCode;//取件码
    string name;//姓名
    string phoneNumber;//电话
    string arrivalDate;//抵达日期
};
int currentDay;//记录当前是星期几 七天一循环
vector<set<int>> codesAvailable;//用于存储三种类型货架仍可以使用的编号
vector<int> roomsLeft;//用于存储三种类型货架的剩余容量
vector<list<package>> packages;//存储包裹 其中每种类型的货架采用双向链表处理 按顺序分别是小 中 大货架
//将出现的取件码放入数组中 便于随机
vector<string> getCodes;
vector<string> phoneNumbers;
vector<string> names;
//建立名字和号码的双向映射
map<string,string> phoneToName;
map<string,string> nameToPhone;
//还需要创建一个数组 存放当天有包裹的人的号码 便于随机
vector<string> phoneNumbersThatHavePackages;
//当天每个人取包裹的数量 采用map容器
map<string,int> numOfGettingPackages;
//创建变量记录包裹数量
int sumOld=0;//原来读入的
int sumNew=0;//新增的
//创建映射记录一周内某人返回的包裹数目 采用map容器 但是建立什么和次数的映射呢？名字？
map<string,int> numOfBackPackages;
//创建变量记录总的返回包裹数
int totalBackPackages;
```

#### 算法设计思想

本题算法设计思想并不复杂，基本采用常规思路即可

+ 排序：采用了STL中的改进式快排的思想

+ 取件：
  + 如果是根据取件码取件，首先遍历货架数组，找到对应包裹存有的手机号，然后再次遍历货架，找到所有手机号信息相同的包裹输出即可
  + 如果是根据手机号取件，则直接遍历货架查找即可
+ 相关统计功能：另开变量存储各统计值即可，其中在统计每个人一周内返回的包裹数目时才用了哈希表 使时间复杂度降为`O(1)`

#### 源代码

```C++
#include<iostream>
#include<vector>
#include<list>
#include<string>
#include<set>
#include<map>
#include<ctime>
#include<fstream>
#include<sstream>
#include<algorithm>

using namespace std;

const int MAX_PERSON = 30;

//包裹类
class package{
public:
    int timeAlreadySaved;//已存放的日期
    int size;//类型 小1、中2、大3
    int code;//编号
    string getCode;//取件码
    string name;//姓名
    string phoneNumber;//电话
    string arrivalDate;//抵达日期
};
int currentDay;//记录当前是星期几 七天一循环
vector<set<int>> codesAvailable;//用于存储三种类型货架仍可以使用的编号
vector<int> roomsLeft;//用于存储三种类型货架的剩余容量
vector<list<package>> packages;//存储包裹 其中每种类型的货架采用双向链表处理 按顺序分别是小 中 大货架
//将出现的取件码放入数组中 便于随机
vector<string> getCodes;
vector<string> phoneNumbers;
vector<string> names;
//建立名字和号码的双向映射
map<string,string> phoneToName;
map<string,string> nameToPhone;
//还需要创建一个数组 存放当天有包裹的人的号码 便于随机
vector<string> phoneNumbersThatHavePackages;
//当天每个人取包裹的数量 采用map容器
map<string,int> numOfGettingPackages;
//创建变量记录包裹数量
int sumOld=0;//原来读入的
int sumNew=0;//新增的
//创建映射记录一周内某人返回的包裹数目 采用map容器 但是建立什么和次数的映射呢？名字？
map<string,int> numOfBackPackages;
//创建变量记录总的返回包裹数
int totalBackPackages;

//谓词
class comparePackage{
public:
    bool operator()(package p1,package p2){
        return p1.code<p2.code;
    }
};
class comparePerson{
public:
    bool operator()(pair<string,int> p1,pair<string,int> p2){
        return p1.second<p2.second;
    }
};

//读取名字和号码函数
//提前随机好 直接读取
void readNameAndPhone(){
    fstream f;
    f.open("name_phone.txt", ios::in);
    if(!f.is_open()){
        cout << "姓名号码读取失败" <<endl;
        exit(0);
    }
    
    string line;
    stringstream ss;
    while(f.peek()!=EOF){
        string name;
        string phone;
        
        getline(f,line);
        ss<<line;
        
        ss>>name;
        ss>>phone;
        
        names.push_back(name);
        phoneNumbers.push_back(phone);
        phoneToName.emplace(phone, name);
        nameToPhone.emplace(name, phone);
        
        ss.clear();
        ss.str("");
    }
}

//读取文件函数
//文件格式：
//1.当前是星期几/n
//2.当前每个人被退回的包裹数量
//3.按照包裹类中的顺序排列的各数据
//注意：在读取完所有数据之后 还需要将所有已经存放两天的包裹删除 并重置辅助数组
void readFromFiles(){
    fstream f;
    f.open("shelves.txt",ios::in);
    if(!f.is_open()){
        cout<<"文件打开失败"<<endl;
        exit(0);
    }
    
    string tempLine;
    
    //读取提示信息
    f>>tempLine;
    
    f>>currentDay;//读入星期几
    //先加1 表示今天
    currentDay++;
    if(currentDay==8){
        //如果到了8 重置为1
        currentDay=1;
    }
    
    //读取提示信息
    f>>tempLine;
    
    //在正式读入数据之前 还要读入已经退回的包裹数
    //如果上面的currentDay变成了星期1 则全部初始化为0
    for(int i=0;i<30;i++){
        string tempName;
        int tempNum;
        f>>tempName;
        f>>tempNum;
        //此处应直接在numOfPackages中创建新对组
        if(currentDay==1){
            numOfBackPackages.emplace(tempName,0);
        }
        numOfBackPackages.emplace(tempName,tempNum);
    }
    
    //读取提示信息
    f>>tempLine;
    f.get();
    
    int saveTimeToCheck;
    while(f.peek()!=EOF){
        string tempString;
        stringstream ss;
        getline(f,tempString);
        ss<<tempString;
        
        ss>>saveTimeToCheck;
        //先将saveTimeToCheck作+1处理（表示今天） 只有+1之后仍然小于等于2的才继续读入（>2的认为需要从货架上删除）
        saveTimeToCheck++;
        if(saveTimeToCheck>2){
            //对应的人的退回包裹数++ 然后进入下一次循环
            int tempSize;
            int tempCode;
            string tempGetCode;
            string tempName;
            ss>>tempSize;
            ss>>tempCode;
            ss>>tempGetCode;
            ss>>tempName;
            numOfBackPackages[tempName]++;
            
            ss.clear();
            ss.str("");
            continue;
        }
        else{
            package p;
            p.timeAlreadySaved=saveTimeToCheck;
            ss>>p.size;
            ss>>p.code;
            ss>>p.getCode;
            ss>>p.name;
            ss>>p.phoneNumber;
            ss>>p.arrivalDate;
            
            packages[p.size-1].emplace_back(p);
            //每加入一个包裹 可使用的编号就要减少 采用集合可以直接对元素本身进行删除
            codesAvailable[p.size-1].erase(p.code);
            //可以使用的空间也有所减少
            roomsLeft[p.size-1]--;
            //每加一个包裹 就要加入到取件码和电话数组中 便于后面随机
            getCodes.push_back(p.getCode);
            phoneNumbersThatHavePackages.push_back(p.phoneNumber);
            //每读入一个 数量都要增加
            sumOld++;
        }
        
        ss.clear();
        ss.str("");
    }
    //读入全部数据后 统计三种货架剩余的容量 统计可用天数即可
    for(int i=0;i<3;i++){
        roomsLeft[i]=codesAvailable[i].size();
    }
    
    cout<<"数据读入成功"<<" 共读入"<<sumOld<<"条数据"<<endl;
    f.close();
}

//添加包裹函数 该函数在实际运用中可以采用从文件读取的形式处理
void addPackages(){
    int n[3];//0 1 2 分别表示随机添加的小 中 大包裹的数量
    srand((unsigned int)time(NULL));//随机种子
    
    //随机添加的量一定要保证在货架承受范围内 出于此考虑要使用roomsLeft
    //可以随机的范围是0——roomsLeft 闭区间
    for(int i=0;i<3;i++){
        n[i]=rand()%(roomsLeft[i]+1);
        if(i==0){
            cout<<"今天要入库的小型包裹数量为:"<<n[i]<<endl;
        }
        else if(i==1){
            cout<<"今天要入库的中型包裹数量为:"<<n[i]<<endl;
        }
        else{
            cout<<"今天要入库的大型包裹数量为:"<<n[i]<<endl;
        }
        sumNew+=n[i];
    }
    
    //开始添加包裹
    for(int k=0;k<3;k++){
        for(int i=0;i<n[k];i++){
            if(k==0){
                cout<<"录入第"<<i+1<<"个小型包裹"<<endl;
            }
            else if(k==1){
                cout<<"录入第"<<i+1<<"个中型包裹"<<endl;
            }
            else{
                cout<<"录入第"<<i+1<<"个大型包裹"<<endl;
            }
            
            package p;
            //p的已存放日期初始化为0
            p.timeAlreadySaved=0;
            p.size=k+1;
            //货架容量-1
            roomsLeft[p.size-1]--;
            //编号是系统指定的
            //取当前可用编号的最小值 注意min_element函数返回的是迭代器
            //另外 需要注意set容器内部是已经排序好的（默认升序） 所以理论上可以直接取第一项
            auto minIter=min_element(codesAvailable[p.size-1].begin(), codesAvailable[p.size-1].end());
            p.code=*minIter;
            //注意要将这一编号从可用编号中除去
            codesAvailable[p.size-1].erase(p.code);
            
            //创建取件码
            //首先将包裹类型和编码转换为字符串 1 2 3 分别对应小中大货架的货架编号
            string str_size=to_string(p.size);
            string str_code=to_string(p.code);
            p.getCode=str_size+'-'+str_code;//字符串拼接
            cout<<"该包裹取件码为："<<p.getCode<<endl;
            //创建后加入数组便于取件随机
            getCodes.push_back(p.getCode);
            
            //从电话数组中随机抽取一个号码
            int r=rand()%(phoneNumbers.size());
            p.phoneNumber=phoneNumbers[r];
            p.name=phoneToName[p.phoneNumber];
            cout<<"收件人电话号码为："<<p.phoneNumber<<endl;
            phoneNumbersThatHavePackages.push_back(p.phoneNumber);
            //将该号码加入到当天有包裹的号码中
            
            //随机创建日期
            string randDate="2022";
            int n1=rand()%2;
            string str_n1=to_string(n1);
            randDate+=str_n1;
            int n2=rand()%10;//取0-9的数
            string str_n2=to_string(n2);
            randDate+=str_n2;
            int n3=rand()%4;//取0-3的数
            string str_n3=to_string(n3);
            randDate+=str_n3;
            int n4=rand()%10;//取0-9的数
            string str_n4=to_string(n4);
            randDate+=str_n4;
            p.arrivalDate=randDate;
            
            //信息随机完毕后 将包裹加入到货架中
            packages[p.size-1].push_back(p);
            cout<<endl;
        }
    }
        //所有包裹上架后 还需要按照包裹编号升序对包裹进行排序
        //注意到是对package对象进行排序 所以需要自己写谓词
        for(int i=0;i<3;i++){
            packages[i].sort(comparePackage());
        }
    
        cout<<"共计"<<sumNew<<"个包裹读入完毕"<<endl;
}

//取包裹函数
void getPackages(){
    srand((unsigned int)time(NULL));
    
    int m;
    //随机范围 0-MAX_PERSON 闭区间
    m=rand()%(MAX_PERSON+1);
    cout<<"今天共有"<<m<<"个人前来取件:"<<endl;
    
    for(int i=0;i<m;i++){
        int choice;
        //随机取件方式 0:取件码 1:电话号码 注意如果是电话号码 需要把所有改人的包裹全部取出
        choice=rand()%2;
        
        if(choice==0){
            cout<<"取件码取件"<<endl;
            //取件码 注意即使是取件码也需要一次性把该人的所有包裹取出 最终也转化成电话取件即可
            //首先随机抽取一个取件码 随机范围是0-getCodes.size()-1
            int r;
            r=rand()%(getCodes.size());
            string getCodeToCheck=getCodes[r];//取码
            
            //根据取件码的第一位锁定货架 getCodeToCheck[0](转化为数字后)-1是货架编号
            char char_sizeToCheck=getCodeToCheck[0];
            int sizeToCheck=char_sizeToCheck-'0';
            //虽然包裹按照编号排序 但由于是链表 迭代器不支持随机 所以不能进行二分查找
            //分离出编号的方法：substr分离出最后的字符串 stoi函数转化为整形数字 然后进行比较
            string str_codeToCheck=getCodeToCheck.substr(2);
            int codeToCheck=stoi(str_codeToCheck);
            
            //根据取件码查找电话号码
            string phoneNumberToCheck;
            for(auto it=packages[sizeToCheck-1].begin();it!=packages[sizeToCheck-1].end();it++){
                if((*it).code==codeToCheck){
                    //找到对应编号后 取电话号码
                    phoneNumberToCheck=(*it).phoneNumber;
                }
            }
            
            cout<<"第"<<i+1<<"位取件人的电话号码为"<<phoneNumberToCheck<<" 取走包裹如下："<<endl;
            //在此处向numOfGettingPackages中插入一个元素
            numOfGettingPackages.emplace(phoneNumberToCheck,0);
            
            //注意要对三个货架都遍历一遍
            for(int j=0;j<3;j++){
                for(auto it=packages[j].begin();it!=packages[j].end();it++){
                    if((*it).phoneNumber==phoneNumberToCheck){
                        //找到电话号码相同的包裹后 先输出包裹的取件码 然后从取件码数组中删除取件码 然后将包裹编号加入可用编号 然后可用容量增加 然后将该包裹从链表中删除
                        //注意还要给该人取走的包裹数量++
                        cout<<(*it).getCode<<endl;
                        auto getCodeIt=find(getCodes.begin(),getCodes.end(),it->getCode);
                        getCodes.erase(getCodeIt);
                        codesAvailable[j].insert((*it).code);
                        roomsLeft[j]++;
                        it=packages[j].erase(it);
                        numOfGettingPackages[phoneNumberToCheck]++;
                        
                        //注意erase函数本身返回的是下一个元素的迭代器 为防止删除不全 要将it前移一次
                        it--;
                    }
                }
            }
            
            //包裹删除完毕 从号码数组中删除号码
            //首先查找号码迭代器
            auto phoneNumberIt=find(phoneNumbersThatHavePackages.begin(),phoneNumbersThatHavePackages.end(),phoneNumberToCheck);
            //然后删除号码
            phoneNumbersThatHavePackages.erase(phoneNumberIt);
        }
        else{
            cout<<"电话号码取件"<<endl;
            
            //直接根据号码删除
            //首先从号码数组中随机出一个号码
            int r;
            r=rand()%(phoneNumbersThatHavePackages.size());
            string phoneNumberToCheck=phoneNumbersThatHavePackages[r];//取码
            
            //取件
            cout<<"第"<<i+1<<"位取件人的电话号码为"<<phoneNumberToCheck<<" 取走包裹如下："<<endl;
            numOfGettingPackages.emplace(phoneNumberToCheck,0);
            
            for(int j=0;j<3;j++){
                for(auto it=packages[j].begin();it!=packages[j].end();it++){
                    if((*it).phoneNumber==phoneNumberToCheck){
                        //找到电话号码相同的包裹后 先输出包裹的取件码 然后从取件码数组中删除取件码 然后将包裹编号加入可用编号 然后可用容量增加 然后将该包裹从链表中删除
                        cout<<(*it).getCode<<endl;
                        //首先在取件码数组中查找该取件码的迭代器
                        auto getCodeIt=find(getCodes.begin(),getCodes.end(),(*it).getCode);
                        //然后删除取件码
                        getCodes.erase(getCodeIt);
                        codesAvailable[j].insert((*it).code);
                        roomsLeft[j]++;
                        it=packages[j].erase(it);
                        numOfGettingPackages[phoneNumberToCheck]++;
                        
                        //注意erase函数本身返回的是下一个元素的迭代器 为防止删除不全 要将it前移一次
                        it--;
                    }
                }
            }
            
            //包裹删除完毕 从号码数组中删除号码
            phoneNumbersThatHavePackages.erase(phoneNumbersThatHavePackages.begin()+r);
        }
    }
}

//信息统计函数
void infoStatistics(){
    cout<<"今天取包裹数量最多的人的电话号码是"<<endl;
    auto maxNumIt=max_element(numOfGettingPackages.begin(), numOfGettingPackages.end(), comparePerson());
    cout<<(*maxNumIt).first<<endl;
    
    cout<<"今天有包裹的人的平均包裹数量是"<<endl;
    int sum=sumOld+sumNew;
    int numOfPersons=phoneNumbers.size();
    int ave=float(sum)/float(numOfPersons);
    cout<<ave<<endl;
    
    //如果是星期天 输出这周内退回的包裹数量
    if(currentDay==7){
        cout<<"本周退回的包裹数量为"<<endl;
        totalBackPackages=0;
        for(string name:names){
            totalBackPackages+=numOfBackPackages[name];
        }
        cout<<totalBackPackages<<endl;
    }
}

//读入文件函数
void outIntoFile(){
    fstream f;
    f.open("shelves.txt",ios::out);
    f<<"星期"<<endl;
    f<<currentDay<<endl;
    
    f<<"当前每人已经被退回的包裹数量"<<endl;
    for(string name:names){
        f << name << ' ' << numOfBackPackages[name] <<endl;
    }
    
    f<<"包裹信息"<<endl;
    for(int i=0;i<3;i++){
        for(auto it=packages[i].begin();it!=packages[i].end();it++){
            f<<it->timeAlreadySaved<<" ";
            f<<it->size<<" ";
            f<<it->code<<" ";
            f<<it->getCode<<" ";
            f<<it->name<<" ";
            f<<it->phoneNumber<<" ";
            f<<it->arrivalDate<<endl;
        }
    }
    f.close();
}

int main(){
    //初始化空间
    codesAvailable.resize(3);
    
    //初始化为全部天数都可以使用 500 100 50 编号从0开始
    for(int i=0;i<3;i++){
        switch (i){
            case 0:
                for(int j=0;j<500;j++){
                    codesAvailable[i].insert(j);
                }
                break;
            case 1:
                for(int j=0;j<100;j++){
                    codesAvailable[i].insert(j);
                }
                break;
            case 2:
                for(int j=0;j<50;j++){
                    codesAvailable[i].insert(j);
                }
                break;
            default:
                break;
        }
    }
    
    roomsLeft.push_back(500);
    roomsLeft.push_back(100);
    roomsLeft.push_back(50);
    
    //初始化空间
    packages.resize(3);
    
    //制作菜单
    readNameAndPhone();
    readFromFiles();
    
    while(1){
        cout<<"-----------------------------"<<endl;
        cout<<"欢迎使用菜鸟管理系统"<<endl;
        cout<<"今天是：星期"<<currentDay<<endl;
        cout<<"请输入您的选择："<<endl;
        cout<<"1.添加包裹"<<endl;
        cout<<"2.取包裹"<<endl;
        cout<<"3.输出统计信息"<<endl;
        cout<<"0.退出系统"<<endl;
        cout<<"-----------------------------"<<endl;
        
        int choice;
        cin>>choice;
        switch(choice){
            case 1:
                addPackages();
                break;
            case 2:
                getPackages();
                break;
            case 3:
                infoStatistics();
                break;
            case 0:
                outIntoFile();
                exit(0);
            default:
                cout<<"输入有误"<<endl;
                break;
        }
    }
    
    return 0;
}
```

#### 测试样例

![tupian1](/Users/plotnickslope/Desktop/截屏/截屏2023-01-16 19.07.56.png)

![tupian2](/Users/plotnickslope/Desktop/截屏/截屏2023-01-16 19.08.35.png)

![tupian3](/Users/plotnickslope/Desktop/截屏/截屏2023-01-16 19.08.41.png)

#### 算法时间复杂度

由于采用了链表，因此查找（取包裹）步骤的复杂度为`O(n)`，插入（添加包裹）步骤的复杂度为`O(1)`

#### 代码行数

528

### 算数表达式求值

#### 数据结构

```C++
vector<float> num; //操作数栈
vector<char> ops;
//构造运算符优先级表 表中1表示大于 0表示等于 -1表示小于 其余特殊情况用另外的数字表示 详见代码 运用字典直接通过运算符进行查找
map<char,map<char,int>> priorities;
pair<float,string> ans; //对组 前面存储答案数字 后面存储读入的表达式
```

#### 算法设计思想

1. 运算符优先级的处理

   预先将书中的优先级表复刻到文件**priorities.txt**中，具体处理规则如下

   + 1 表示>
   + 0 表示=
   + -1表示<
   + 2 表示存在没有右括号与之匹配的左括号
   + 3 表示存在右括号违规入栈
   + 4 表示存在没有左括号与之匹配的右括号 表达式有误

   ![youxianji](/Users/plotnickslope/Desktop/截屏/截屏2023-01-18 09.29.41.png)

   > 自己拟定的运算符优先级表展示

2. 运算符读取

   原则上 是数字就存入操作数栈，是字符就存入运算符栈 但考虑到负数的情况 需要对如下情况做出讨论

   > 当前读入的运算符是'-' 且前一位读入的字符也是运算符

    这种情况表明当前读入的'-'实际上是负号，因此不能将该‘-’存入运算符栈中，而应该再读入下一位数字（此处默认负号的后面一定是数字）然后将数字的相反数存入操作数栈即可

3. 运算

   每读入一位运算符 都与栈顶的运算符进行比较 有如下讨论

   + 若运算符栈中算符优先级更高，则从操作数栈弹出两数先进行栈中算符的运算，然后将该算符弹出，循环比较
   + 若运算符栈中算符优先级更低，则将当前用于比较的运算符入栈
   + 若运算符栈中算符优先级相等，则说明左右括号相遇 直接将栈中算符弹出即可

#### 源代码

```C++
#include<iostream>
#include<vector>
#include<string>
#include<map>
#include<fstream>
using namespace std;

vector<float> num;
vector<char> ops;
//构造运算符优先级表 表中1表示大于 0表示等于 -1表示小于 运用字典直接通过运算符进行查找
map<char,map<char,int>> priorities;
pair<float,string> ans;

//创建优先级表
void make_priorities(map<char,map<char,int>> &priorities){
    fstream f;
    f.open("priorities.txt",ios::in);//打开表文件
    if(!f.is_open()){
        cout<<"文件打开失败"<<endl;
        exit(0);
    }
    
    //文件第一行依次输入运算符 按顺序存储在一个线性表中
    vector<char> v;
    //共七个运算符
    for(int i=0;i<7;i++){
        char x;
        f>>x;//从文件读入一个字符
        v.push_back(x);
    }
    
    //开始创建优先级表
    for(int i=0;i<7;i++){
        for(int j=0;j<7;j++){
            int x;
            f>>x;
            priorities[v[i]][v[j]]=x;
        }
    }
    
    //创建完毕 关闭文件
    f.close();
}

//运算符比较函数 返回标志
int compareOperators(char opToCheck,map<char,map<char,int>> &priorities,vector<char> &ops){
    return priorities[ops.back()][opToCheck];
}

//运算函数
pair<float,string> calculate(vector<float> &num,vector<char> &ops,map<char,map<char,int>> &priorities){
    int count=0;//记录操作步骤数
    
    //创建字符串储存读取的表达式
    string expression;
    
    //从文件读入待求表达式
    fstream f;
    f.open("expression.txt",ios::in);
    if(!f.is_open()){
        cout<<"文件打开失败"<<endl;
        exit(0);
    }
    
    //逐个读取表达式中的字符 读取结束时 运算结束
    char ch;
    char lastCh; //考虑负号的情况 需要存储上一位读入的字符
    
    while((ch=f.get())!=EOF){
        count++;
        expression+=ch;
        if(ch>='0'&&ch<='9'){
            //是数字
            //注意要先处理成数字再入栈
            ch=ch-'0';
            num.push_back(ch);
        }
        else if(ch=='+'||ch=='-'||ch=='*'||ch=='/'||ch=='('||ch==')'||ch=='#'){
            //是运算符
            //第一个步骤中 没有可以比较的运算符 应直接将输入的#放入运算符栈中
            if(count==1&&ch=='#'){
                ops.push_back(ch);
                cout<<"步骤"<<count<<"完成后："<<endl;
                cout<<"已经输入并完成操作的序列为："<<expression<<endl;
                cout<<"操作数栈中从底到顶元素为："<<endl;
                
                for(int i=0;i<num.size();i++){
                    cout<<num[i]<<" ";
                }
                cout<<endl;
                cout<<"运算符栈中从底到顶元素为"<<endl;
                
                for(int i=0;i<ops.size();i++){
                    cout<<ops[i]<<" ";
                }
                cout<<endl;
                lastCh=ch;
                continue;
            }
            else if(count==1&&ch!='#'){
                cout<<"输入有误 表达式应以#开头"<<endl;
                exit(0);
            }
            if(count>=2&&ch=='-'&&(lastCh=='+'||lastCh=='-'||lastCh=='*'||lastCh=='/'||lastCh=='('||lastCh==')'||lastCh=='#')){
                //当前读入的运算符是- 且前一位读入的运算符不是数字 表明当前的-是一个负号 需要再读入一个数字并转为负数计入操作数
                ch=f.get();
                expression+=ch;
                if(ch<'0'||ch>'9'){
                    cout<<"输入有误 负号后没有数字"<<endl;
                    exit(0);
                }
                else{
                    ch=ch-'0';
                    ch*=(-1);
                    num.push_back(ch);
                    cout<<"步骤"<<count<<"完成后："<<endl;
                    cout<<"已经输入并完成操作的序列为："<<expression<<endl;
                    
                    cout<<"操作数栈中从底到顶元素为："<<endl;
                    for(int i=0;i<num.size();i++){
                        cout<<num[i]<<" ";
                    }
                    cout<<endl;
                    
                    cout<<"运算符栈中从底到顶元素为"<<endl;
                    for(int i=0;i<ops.size();i++){
                        cout<<ops[i]<<" ";
                    }
                    cout<<endl;
                    continue;
                }
            }
            //传入比较函数进行比较
            int flag;
            flag=compareOperators(ch, priorities, ops);
            
            //先考虑特殊情况
            if(flag==2){
                cout<<"存在没有右括号与之匹配的左括号 表达式有误"<<endl;
                exit(0);
            }
            else if(flag==3){
                cout<<"存在右括号违规入栈"<<endl;
                exit(0);
            }
            else if(flag==4){
                cout<<"存在没有左括号与之匹配的右括号 表达式有误"<<endl;
                exit(0);
            }
            else if(flag==1){
                //栈中运算符优先级更高 先进行栈中运算符的运算
                //由于可能出现运算完之后栈顶运算符还是比当前比对运算符高的情况
                //所以使用do-while语句 先执行一次 然后再次进行比对
                //另外需注意 括号相见的情况一定是包含在。
                do{
                    char opToCalCulate=ops.back();
                    ops.pop_back();//运算符弹栈
                    
                    float v1=num.back();
                    num.pop_back();
                    float v2=num.back();
                    num.pop_back();//弹出两个数
                    
                    //下入栈运算结果
                    if(opToCalCulate=='+'){
                        num.push_back(v1+v2);
                    }
                    //注意 -不满足交换律 弹出两数的运算次序要颠倒
                    if(opToCalCulate=='-'){
                        num.push_back(v2-v1);
                    }
                    if(opToCalCulate=='*'){
                        num.push_back(v1*v2);
                    }
                    //注意 /不满足交换律 弹出两数的运算次序要颠倒
                    if(opToCalCulate=='/'){
                        num.push_back(v2/v1);
                    }
                }while((flag=compareOperators(ch, priorities, ops))==1);//只要栈顶运算符仍大于ch 就一直操作
                //退出该循环时 flag只可能为-1或0
                if(flag==-1){
                    //栈顶元素比ch小 ch入栈
                    ops.push_back(ch);
                }
                else if(flag==0){
                    //右左括号相见 左括号出栈即可
                    ops.pop_back();
                }
            }
            else if(flag==-1){
                //栈中运算符优先级更低
                //将读取的运算符入栈
                ops.push_back(ch);
            }
            else if(flag==0){
                //是右左括号相见 出栈即可
                ops.pop_back();
            }
        }
        else{
            //不合规
            cout<<"表达式存在违法字符"<<endl;
            exit(0);
        }
        lastCh=ch;
        //由于要展示输入序列和栈的变化过程 所以每次操作完要输出一下
        cout<<"步骤"<<count<<"完成后："<<endl;
        cout<<"已经输入并完成操作的序列为："<<expression<<endl;
        
        cout<<"操作数栈中从底到顶元素为："<<endl;
        for(int i=0;i<num.size();i++){
            cout<<num[i]<<" ";
        }
        cout<<endl;
        
        cout<<"运算符栈中从底到顶元素为"<<endl;
        for(int i=0;i<ops.size();i++){
            cout<<ops[i]<<" ";
        }
        cout<<endl;
    }
    //操作完毕 关闭文件
    f.close();
    //正常情况下 此时的num栈中只剩下了一个数
    pair<float, string>p(num.back(),expression);
    return p;
}

int main(){
    make_priorities(priorities);
    ans=calculate(num, ops, priorities);
    cout<<ans.second<<" = "<<ans.first<<endl;
    return 0;
}
```

#### 测试样例

+ 样例1 **3*(-1)+2**

  ![yangli11](/Users/plotnickslope/Desktop/截屏/截屏2023-01-18 10.50.27.png)

  ![截屏2023-01-18 10.50.29](/Users/plotnickslope/Desktop/截屏/截屏2023-01-18 10.50.29.png)

+ 样例2 **3+4*2-(1+1)**

  ![yanglli2](/Users/plotnickslope/Desktop/截屏/截屏2023-01-18 10.53.29.png)

  ![截屏2023-01-18 10.53.38](/Users/plotnickslope/Desktop/截屏/截屏2023-01-18 10.53.38.png)

  ![截屏2023-01-18 10.53.40](/Users/plotnickslope/Desktop/截屏/截屏2023-01-18 10.53.40.png)

#### 算法时间复杂度

由于全程只对表达式符号进行了一次遍历 且入栈弹栈的复杂度均为`O(1)` 所以总时间复杂度为`O(n)`,n表示表达式符号总数

#### 代码行数

234

### 特殊路径统计

#### 数据结构

```C++
//创建数组存储所有节点
vector<TreeNode*> Nodes;
//标记某两点之间的路径是否已经访问
vector<vector<bool>> ifVisited;
//创建统计量
int count=0;
//树节点类
class TreeNode{
public:
    int code;
    vector<TreeNode*> children;
};
```

#### 算法设计思想

总体的算法是DFS的剪枝版本

一条合适的路径满足的规律是由前两个点确定的，具体而言可以如下概括

+ 规定的起点与其任意子节点构成的路径一定满足要求
+ 若起点<起点的子节点 后面的点大于前面所有编号的最大值则找到路径 如果后面的点在不大于最大值的情况下小于最小值 直接剪枝 否则继续搜索
+ 若起点>起点的子节点 后面的点小于前面所有编号的最小值则找到路径 如果后面的点在不小于最小值的情况下大于最大值 直接剪枝 否则继续搜索

#### 源代码

```C++
#include<iostream>
#include<vector>
//算法：DFS
//用一个二维数组来记录某条路径是否有访问过 1表示访问过 0表示没有
//树中任意两点间路径是唯一的
using namespace std;

class TreeNode{
public:
    int code;
    vector<TreeNode*> children;
};

//flag 0表示未初始化
//1表示首两点升序 后面的点大于前面所有编号的最大值则找到路径 如果后面的点在不大于最大值的情况下小于最小值 直接剪枝
//-1表示首两点降序 后面的点小于前面所有编号的最小值则找到路径 如果后面的点在不小于最小值的情况下大于最大值 直接剪枝
void DFS(int startCode,int endCode,int maxCode,int minCode,vector<TreeNode*> &Nodes,vector<vector<bool>> &ifVisited,int &count,int &flag){
    //首先将起点到终点的路径标记为已访问
    ifVisited[startCode][endCode]=true;
    //注意反向路径也要标记
    ifVisited[endCode][startCode]=true;
    //然后检查当前该路径是否满足要求
    if(flag==0 && startCode!=endCode){
        //起始点不为终点表明已经不是第一层递归
        //不是第一层递归的情况下，flag为0表示是第二层递归 需要为flag确定值
        //同时 第二层递归时 endCode为起点的子节点 该路径一定满足要求 所以直接给count++
        count++;
        //确定后续递归时flag的值
        if(endCode>startCode){
            //升序
            flag=1;
            //更改最大值
            maxCode=endCode;
        }
        else{
            //降序
            flag=-1;
            //更改最小值
            minCode=endCode;
        }//前面说明了不存在相等情况
    }
    //上面的if的否定条件为 flag！=0或start==end 后面的情况表明在起点 无需比较 需要排除
    else if(startCode!=endCode){
        //flag不为0 且起点不等于终点 这种情况表明已到达比第二层更深的递归 根据flag进行比较
        if(flag==1){
            if(endCode>maxCode){
                count++;
                maxCode=endCode;
            }
            else if(endCode<minCode){
                //如果在不大于最大值的情况下 还比最小值要小 直接剪枝
                return;
            }
        }
        //flag不为0 且起点不等于终点 这种情况表明已到达比第二层更深的递归 根据flag进行比较
        else{//flag只可能为0 1 -1
            if(endCode<minCode){
                count++;
                minCode=endCode;
            }
            else if(endCode>maxCode){
                //如果在不大于最大值的情况下 还比最小值要小 直接剪枝
                return;
            }
        }
    }
    //访问所有子节点
    //迭代器初始化为指向endCode第一个子节点
    auto it=Nodes[endCode]->children.begin();
    while(it<Nodes[endCode]->children.end()){
        //首先将newEndCode赋值为子节点的code
        int newEndCode=(*it)->code;
        if(ifVisited[startCode][newEndCode]==false){
            DFS(startCode, newEndCode, maxCode, minCode, Nodes, ifVisited, count, flag);
        }
        //访问完一个子节点之后记得要偏移
        it++;
    }
}
int main(){
    int n;//结点数量
    cin>>n;
    //创建变量记录根节点的编号
    int root;
    //创建数组存储所有节点
    vector<TreeNode*> Nodes;
    for(int i=0;i<n+1;i++){//注意编号是从1到n 所以要循环到n+1 0号浪费掉即可
        TreeNode *newNode=new TreeNode;
        newNode->code=i;
        //忘记插入Nodes了……
        Nodes.push_back(newNode);
    }
    //输入父节点
    for(int i=1;i<n+1;i++){
        int p;
        cin>>p;//父节点编号
        if(p==0){
            root=i;
            continue;
        }
        //将当前节点的指针 存入父节点的children中
        Nodes[p]->children.push_back(Nodes[i]);
        //本题需要将树视为无向图处理 所以还要将上述操作反向操作一次
        Nodes[i]->children.push_back(Nodes[p]);
    }
    //标记某两点之间的路径是否已经访问
    vector<vector<bool>> ifVisited;
    ifVisited.resize(n+1);
    for(int i=0;i<n+1;i++){
        ifVisited[i].resize(n+1,false);
    }//初始化
    //创建统计量
    int count=0;
    //算法：编号从小到大 所有点走一遍DFS
    for(int i=1;i<n+1;i++){
        int flag=0;
        DFS(i, i, i, i, Nodes, ifVisited, count, flag);
    }
    cout<<"总路径数为:"<<endl;
    cout<<count<<endl;
    return 0;
}
```

#### 测试样例

![ceshi1](/Users/plotnickslope/Desktop/截屏/截屏2023-01-18 22.57.48.png)

![ceshi2](/Users/plotnickslope/Desktop/截屏/截屏2023-01-18 22.58.06.png)

#### 算法时间复杂度

基于DFS 复杂度为`O(n+m)`其中n为点数 m为边数

#### 代码行数

122

### 公交线路提示

#### 数据结构

```C++
const int inf=99999;//自己定义出的正无穷是dijkstra算法的最佳解决方案
class stop{
public:
    //信息类 包含信息如下
    //1.公交站点的编号 注意是从0开始的
    //2.站点的真实名称
    //3.该条信息中的公交名称（经过该站点的公交名称）
    int stopCode;
    string stopName;
    string currentBusName;
    //构造函数
    stop(int stopCode,string stopName,string currentBusName){
        this->stopCode=stopCode;
        this->stopName=stopName;
        this->currentBusName=currentBusName;
    }
};
vector<vector<stop>> StopsInfos;
//站点信息数组 其中的每个元素也是一个数组
map<string,int> codesOfStops;
//建立由车站名称到车站编号映射的哈希表
map<int, string> namesOfStops;
//建立由车站编号到车站名称的哈希表
map<int, vector<string>> busesThatCanReachTheStop;
//建立哈希表 存储可以到达某编号站点的公交车名称
int m[6000][6000];
//邻接矩阵
```

#### 算法设计思想

本题的思路采用的是邻接矩阵 + Dijkstra算法

+ 对于最少换乘问题， 首先遍历信息数组`StopsInfos`， 对站点作如下讨论：
  + 自己到自己的距离为0
  + 在同一公交线内部的两站点距离为1
  + 从未出现在同一公交线内部的两站点距离设为`inf`

  通过Dijkstra算法后， 从终点站的编号开始， 依次将邻接点的编号入栈， 然后依次出栈， 在`busesThatCanReachTheStop`中找到所有能同时到达两相邻站点的公交车， 存入答案容器，依次输出车站名与公交车名即可

+ 对于最少站点问题，另开一个矩阵`fromWhichBus`存储两两站点间最少站点方案中使用的公交车，首先按照公交线遍历信息数组`StopsInfos`，在每条公交线中， 依次计算当前公交线中的站点两两之间经过的站点数（用下标相减即可）并存入邻接矩阵。当在不同公交线中统计发现存在经过站点数更小的情况时， 更新邻接矩阵中的站点数， 同时更新`fromWhichBus`中的公交名称。对无法相互到达的点， 邻接矩阵中计为`inf`

  通过Dijkstra算法后， 从终点站的编号开始， 依次将邻接点的编号入栈， 然后依次出栈， 在`fromWhichBus`中找到相邻两站点间最少换乘方案所使用的公交车， 存入答案容器， 依次输出车站名与公交车名即可

#### 源代码

```C++
#include<iostream>
#include<vector>
#include<sstream>
#include<fstream>
#include<string>
#include<map>
#include<stack>
#include<algorithm>
using namespace std;
const int inf=99999;//自己定义出的正无穷是dijkstra算法的最佳解决方案
class stop{
public:
    //信息类 包含信息如下
    //1.公交站点的编号 注意是从0开始的
    //2.站点的真实名称
    //3.该条信息中的公交名称（经过该站点的公交名称）
    int stopCode;
    string stopName;
    string currentBusName;
    //构造函数
    stop(int stopCode,string stopName,string currentBusName){
        this->stopCode=stopCode;
        this->stopName=stopName;
        this->currentBusName=currentBusName;
    }
};
vector<vector<stop>> StopsInfos;
//站点信息数组 其中的每个元素也是一个数组
map<string,int> codesOfStops;
//建立由车站名称到车站编号映射的哈希表
map<int, string> namesOfStops;
//建立由车站编号到车站名称的哈希表
map<int, vector<string>> busesThatCanReachTheStop;
//建立哈希表 存储可以到达某编号站点的公交车名称
int m[6000][6000];
//邻接矩阵
void inputFromFile(){
    fstream f;
    f.open("南京公交线路.txt",ios::in);
    if(!f.is_open()){
        cout<<"文件打开失败"<<endl;
    }
    //配合字符串流按行读取
    string tempLine;
    stringstream ss;
    string tempBusName,tempStopName;
    int newCodeOfStop=0;//车站的起始可用编号为0
    while(f.peek()!=EOF){
        getline(f, tempLine);//从文件中读取一行 存入s中
        ss<<tempLine;//存入流
        ss>>tempBusName;//从流中读入时 遇到空格停止
        //创建该条信息的数组
        vector<stop> tempVector;
        //开始加入后续站点信息
        while(ss){//只要ss中还有东西 就一直读取
            //以，作为截断符读取
            getline(ss, tempStopName, ',');
            //如果是第一个站点 注意前面是有空格的 需要去掉空格
            if(isascii(tempStopName[0])&&isspace(tempStopName[0])){
                //如果有空格 删除空格
                tempStopName.erase(tempStopName.begin(),tempStopName.begin()+3);
            }
            //在加入站点前同时完成对其的编号 编号从0开始
            if(codesOfStops.find(tempStopName)==codesOfStops.end()){
                codesOfStops[tempStopName]=newCodeOfStop;
                //同时建立编号到车站名的映射
                namesOfStops[newCodeOfStop]=tempStopName;
                //新编号确定后 待选编号自增
                newCodeOfStop++;
            }
            //将当前公交加入到可以到达当前站点的数组中
            busesThatCanReachTheStop[codesOfStops[tempStopName]].push_back(tempBusName);
            //加入新站点
            tempVector.push_back(stop(codesOfStops[tempStopName], tempStopName, tempBusName));
        }
        //临时数组读取完毕后 将其加入到信息数组中
        StopsInfos.push_back(tempVector);
        //接下来是使用字符串流读取数据的常规操作
        ss.clear();//清空标志位
        ss.str("");//释放内存
    }
    cout<<"文件读入成功"<<endl;
}
void Dijkstra(int startCode,int *nearestAdjVex,int *minDistance,bool *flags,int numOfStops,int m[6000][6000]){
    for(int i=0;i<numOfStops-1;i++){
        //只需循环n-1次
        //每次从未被选中的点中选出一个当前距离最小的
        int minDis=inf;
        int minCode=-1;
        for(int j=0;j<numOfStops;j++){
            if(flags[j]==0&&minDistance[j]<minDis){
                minDis=minDistance[j];
                minCode=j;
            }
        }
        //选出来后 比较该点和所有未被纳入点的距离 如果更小 就更新最近点和最短距离
        //首先要将该点的标志置为已访问
        flags[minCode]=true;
        for(int j=0;j<numOfStops;j++){
            //只判断此时标志仍然为0的点
            if(flags[j]==false){
                if(minDistance[minCode]+m[minCode][j]<minDistance[j]){
                    minDistance[j]=minDistance[minCode]+m[minCode][j];
                    nearestAdjVex[j]=minCode;
                }
            }
        }
    }
    //进行完循环后 此时的三个数组中已经有答案了
}
//最少换乘
void LeastBus(string startStop,string endStop){
    //首先创建最少换乘临界矩阵 所有位于同一条公交线内部的车站 都认为其距离为1 自己到自己的距离为0 遍历完之后剩下的位置表示的是无法直达的点 将距离设置为inf
    if(codesOfStops.find(startStop)==codesOfStops.end()||codesOfStops.find(endStop)==codesOfStops.end()){
        cout<<"至少一个车站不存在"<<endl;
        return;
    }
    if(startStop==endStop){
        cout<<"起点与终点相同 无需乘车"<<endl;
        return;
    }
    int numOfStops=codesOfStops.size();
    //矩阵初始化
    for(int i=0;i<numOfStops;i++){
        for(int j=0;j<numOfStops;j++){
            if(i==j){
                m[i][j]=0;
            }
            else{
                m[i][j]=inf;
            }
        }
    }
    //读入数据
    for(int i=0;i<StopsInfos.size();i++){
        for(int j=0;j<StopsInfos[i].size()-1;j++){
            for(int k=j+1;k<StopsInfos[i].size();k++){
                m[StopsInfos[i][j].stopCode][StopsInfos[i][k].stopCode]=1;
                //注意 由于公交车是可以反向的 所以对称位也要置1
                m[StopsInfos[i][k].stopCode][StopsInfos[i][j].stopCode]=1;
            }
        }
    }
    //下面准备开始进行 dijkstra算法
    //首先取得两个站点所对的编号
    int startCode=codesOfStops[startStop];
    int endCode=codesOfStops[endStop];
    //三个辅助数组
    int *nearestAdjVex=new int[numOfStops];
    int *minDistance=new int[numOfStops];
    bool *flags=new bool[numOfStops];
    //将三个数组初始化
    for(int i=0;i<numOfStops;i++){
        nearestAdjVex[i]=startCode;
        minDistance[i]=m[startCode][i];
        flags[i]=false;
    }
    //注意要将起始点的访问标志置为真
    flags[startCode]=true;
    //传入起点 三个数组 与站点总数 开始dijkstra算法
    Dijkstra(startCode, nearestAdjVex, minDistance, flags, numOfStops, m);
    //从三个数组中读取答案并输出
    //存储最少乘车次数
    int minTimes=minDistance[endCode];
    cout<<"最少乘车次数为："<<minTimes<<endl;
    //然后从endCode开始逆向读取站点间的最短路径 用栈实现
    stack<int> minStops;
    int codeToCheck=endCode;
    while(codeToCheck!=nearestAdjVex[codeToCheck]){
        //当上面两个东西相等时 表示已经回溯到了起点
        minStops.push(codeToCheck);
        codeToCheck=nearestAdjVex[codeToCheck];
    }
    //此时栈中存放的是起点之后第一个点到终点的路径
    //接下来找对应的公交车
    //设立一个比较站 初始化为起点 每次从栈中取一个点 找到同时经过这两个站点的公交车 正向计入答案 然后将比较站初始化为取出的点
    int compStop=startCode;
    cout<<"乘车方案为："<<endl;
    //首先输出起点
    cout<<namesOfStops[startCode]<<"->";
    //注意 由于能直达两站点的公交车可能有多辆 所以要用或的方式全部统计出来并输出
    while(!minStops.empty()){
        vector<string> ans;
        int currentStop=minStops.top();
        int busNum1=busesThatCanReachTheStop[compStop].size();
        int busNum2=busesThatCanReachTheStop[currentStop].size();
        for(int i=0;i<busNum1;i++){
            for(int j=0;j<busNum2;j++){
                if(busesThatCanReachTheStop[compStop][i]==busesThatCanReachTheStop[currentStop][j]){
                    //注意要去重 如果找到的公交车是一样的 就不用加入答案中了
                    if(find(ans.begin(),ans.end(),busesThatCanReachTheStop[compStop][i])==ans.end()){
                        ans.push_back(busesThatCanReachTheStop[compStop][i]);
                        //没找到 就加入
                    }
                }
            }
        }
        //ans找到后 输出当前可乘公交车和到达的站点
        for(int i=0;i<ans.size();i++){
            cout<<ans[i];
            if(i!=ans.size()-1){
                cout<<"/";
            }
            else{
                cout<<"->";
            }
        }
        if(minStops.size()>1){
            cout<<namesOfStops[currentStop]<<"->";
        }
        else{
            cout<<namesOfStops[currentStop];
        }
        //出栈
        minStops.pop();
        //偏移
        compStop=currentStop;
    }
    cout<<endl;
}
//最少站点
void LeastStop(string startStop,string endStop){
    cout<<"以下输出经过最少站点的方案："<<endl;
    //创建邻接网 网中的权值是任意两站之间经过的最少站点数（可用下标相减得到）同时要另开数组用来记录这一最小站点方案下使用的公交车
    vector<vector<string>> fromWhichBus;//存储两站点之间最少站点方案坐的是什么公交车
    if(codesOfStops.find(startStop)==codesOfStops.end()||codesOfStops.find(endStop)==codesOfStops.end()){
        cout<<"至少一个车站不存在"<<endl;
        return;
    }
    if(startStop==endStop){
        cout<<"起点与终点相同 无需乘车"<<endl;
        return;
    }
    int numOfStops=codesOfStops.size();
    //距离矩阵初始化
    for(int i=0;i<numOfStops;i++){
        for(int j=0;j<numOfStops;j++){
            if(i==j){
                m[i][j]=0;
            }
            else{
                m[i][j]=inf;
            }
        }
    }
    //方案公交矩阵初始化
    fromWhichBus.resize(numOfStops);
    for(int i=0;i<numOfStops;i++){
        fromWhichBus[i].resize(numOfStops);
    }
    //读入数据
    for(int i=0;i<StopsInfos.size();i++){
        for(int j=0;j<StopsInfos[i].size()-1;j++){
            for(int k=j+1;k<StopsInfos[i].size();k++){
                int newDistance=k-j;
                int currentDistance=m[StopsInfos[i][j].stopCode][StopsInfos[i][k].stopCode];
                if(newDistance<currentDistance){
                    m[StopsInfos[i][j].stopCode][StopsInfos[i][k].stopCode]=newDistance;
                    m[StopsInfos[i][k].stopCode][StopsInfos[i][j].stopCode]=newDistance;
                    fromWhichBus[StopsInfos[i][j].stopCode][StopsInfos[i][k].stopCode]=StopsInfos[i][j].currentBusName;
                    fromWhichBus[StopsInfos[i][k].stopCode][StopsInfos[i][j].stopCode]=StopsInfos[i][k].currentBusName;
                }
            }
        }
    }
    //下面准备开始进行 dijkstra算法
    //首先取得两个站点所对的编号
    int startCode=codesOfStops[startStop];
    int endCode=codesOfStops[endStop];
    //三个辅助数组
    int *nearestAdjVex=new int[numOfStops];
    int *minDistance=new int[numOfStops];
    bool *flags=new bool[numOfStops];
    //将三个数组初始化
    for(int i=0;i<numOfStops;i++){
        nearestAdjVex[i]=startCode;
        minDistance[i]=m[startCode][i];
        flags[i]=false;
    }
    //注意要将起始点的访问标志置为真
    flags[startCode]=true;
    //传入起点 三个数组 与站点总数 开始dijkstra算法
    Dijkstra(startCode, nearestAdjVex, minDistance, flags, numOfStops, m);
    //从三个数组中读取答案并输出
    //存储经过的最少站点数
    int minNumOfStops=minDistance[endCode];
    cout<<"经过最少站点数为（不包括起点 包括终点）："<<minNumOfStops<<endl;
    //然后从endCode开始逆向读取站点间的最短路径 用栈实现
    stack<int> minStops;
    int codeToCheck=endCode;
    while(codeToCheck!=nearestAdjVex[codeToCheck]){
        //当上面两个东西相等时 表示已经回溯到了起点
        minStops.push(codeToCheck);
        codeToCheck=nearestAdjVex[codeToCheck];
    }
    //此时栈中存放的是起点之后第一个点到终点的路径
    //接下来要做的事情是依次从之前确定的数组中取出最小路径下到达某站点的公交车名称 依次输出车站和公交车名称
    //设立一个比较站 初始化为起点 每次从栈中取一个点 找到同时经过这两个站点的公交车 正向计入答案 然后将比较站初始化为取出的点
    int compStop=startCode;
    cout<<"乘车方案为："<<endl;
    //首先输出起点
    cout<<namesOfStops[startCode]<<"->";
    //注意 由于能直达两站点的公交车可能有多辆 所以要用或的方式全部统计出来并输出
    while(!minStops.empty()){
        int currentStop=minStops.top();
        //先输出公交再输出站点
        cout<<fromWhichBus[compStop][currentStop]<<"->";
        if(minStops.size()>1){
            cout<<namesOfStops[currentStop]<<"->";
        }
        else{
            cout<<namesOfStops[currentStop];
        }
        //出栈
        minStops.pop();
        //偏移
        compStop=currentStop;
    }
    cout<<endl;
}
int main(){
    inputFromFile();
    cout<<"欢迎使用公交提示系统"<<endl;
    cout<<"请输入任意两站点的名称 用空格分割 输入任意个#以关闭系统"<<endl;
    while(1){
        string s1;
        string s2;
        cout<<"请输入第一个站点名称："<<endl;
        cin>>s1;
        cout<<"请输入第二个站点名称"<<endl;
        cin>>s2;
        if(s1=="#"||s2=="#"){
            cout<<"感谢您的使用"<<endl;
            exit(0);
        }
        LeastBus(s1, s2);
        cout<<endl;
        LeastStop(s1, s2);
    }
    return 0;
}
```

#### 测试样例

![公交系统测试案例](/Users/plotnickslope/Library/Mobile Documents/com~apple~CloudDocs/数据结构/课设/报告/公交系统测试案例.png)

#### 算法时间复杂度及改进方案

除数据处理之外 本程序核心算法Dijkstra时间复杂度为O(n^2^ + m)，其中`n`指邻接矩阵对应的图的点数， `m`指邻接矩阵对应的图的边数

另，本体的数据结构与算法可以改为邻接表 + BFS改良的形式，可以将时间复杂度降到`O(n + m)`对本题而言，效率更高

#### 代码行数

341

### 哈夫曼编码

#### 数据结构

```C++
const int inf=99999;
//字符类
class character{
public:
    character(char ch){
        this->ch=ch;
    }
    character(){
        
    }
    char ch;//字符
    vector<int> code;//采用数组的形式来存储所有的编码数字 便于转化为二进制
};
//哈夫曼树节点
class HTnode{
public:
    HTnode(int weight,int parent,int lchild,int rchild){
        this->weight=weight;
        this->parent=parent;
        this->lchild=lchild;
        this->rchild=rchild;
    }
    HTnode(){
        
    }
    int weight;
    int parent;
    int lchild;
    int rchild;
};
map<char,int> timesAppear;//建立哈希表用来统计每个字符出现的次数
vector<character> chs;//将所有字符型存储在一个数组中 数组中的下标就是其编号 注意编号从1开始 0号是废空间
vector<HTnode> treeNodes;//储存哈夫曼树节点信息
map<string,char> codeToCh;//建立由编码到字符的映射 此处的编码采用string格式 解二进制码时使用
map<char,vector<int>> chToCode;//建立由字符到其编号的映射 此处的编号采用数组格式 编二进制码时使用
```

#### 算法设计思想

+ 在统计各字符出现次数时 采用了哈希表，使时间复杂度降到了`O(1)`
+ 编码与解码
  + 构建哈夫曼树，对每个叶子节点从叶到根回溯，得到每个字符的编码，将编码存入每个`chs`类的`code`容器中，以字符数组的形式保存，同时建立`codeToCh`和`chToCode`两个哈希表
  + 编码时，首先读取整篇文章，查询`chToCode`，将每个字符的编码按照文章顺序全部存入一个大数组中，然后每八位为一个周期读取大数组中的编码，将八位编码视为二进制数计算为十进制数后，强制转换为`char`型，并以二进制写的模式写入`code.dat`中
  + 解码时，从`code.dat`中每次读入一个`char`型，通过`(char+256)%256`的方式将其转换为十进制，然后再将其转化为二进制数以数组形式存放 ，所有字符读取完毕后，从头开始检索存放了所有二进制数的大数组，结合`codeToCh`遇到合适的编码就转化为字符写入`recode.txt`

#### 源代码

```C++
#include<iostream>
#include<map>
#include<fstream>
#include<vector>
#include<stack>
#include<cmath>
using namespace std;
const int inf=99999;
class character{
public:
    character(char ch){
        this->ch=ch;
    }
    character(){
        
    }
    char ch;//字符
    vector<int> code;//采用数组的形式来存储所有的编码数字 便于转化为二进制
};
class HTnode{
public:
    HTnode(int weight,int parent,int lchild,int rchild){
        this->weight=weight;
        this->parent=parent;
        this->lchild=lchild;
        this->rchild=rchild;
    }
    HTnode(){
        
    }
    int weight;
    int parent;
    int lchild;
    int rchild;
};
map<char,int> timesAppear;//建立哈希表用来统计每个字符出现的次数
vector<character> chs;//将所有字符型存储在一个数组中 数组中的下标就是其编号 注意编号从1开始 0号是废空间
vector<HTnode> treeNodes;//储存哈夫曼树节点信息
map<string,char> codeToCh;//建立由编码到字符的映射 此处的编码采用string格式 解二进制码时使用
map<char,vector<int>> chToCode;//建立由字符到其编号的映射 此处的编号采用数组格式 编二进制码时使用
//统计次数
void calculateTimes(){
    character abandonCh;
    chs.push_back(abandonCh);//插入废弃字符 使数组下标从1开始
    fstream f;
    f.open("Huffman编码材料.txt",ios::in);
    if(!f.is_open()){
        cout<<"文件打开失败"<<endl;
    }
    char chToCheck;
    while(f.get(chToCheck)){
        //注意在某些系统中 换行是\r\n而不是直接\n 由于换行只统计一次 所以不统计\r了
        if(chToCheck=='\r'){
            continue;
        }
        //查找在哈希表中是否存在以该字符为键的键值对 如果不存在 就建立映射 如果存在 次数++
        if(timesAppear.find(chToCheck)==timesAppear.end()){
            timesAppear[chToCheck]=1;
            //除了统计字数之外 读到新的字符时 还要将其加入到字符型数组中
            character newCh(chToCheck);
            chs.push_back(newCh);
        }
        else{
            timesAppear[chToCheck]++;
        }
    }
    f.close();
}
//文件输出编码结果
void saveToTxt(){
    fstream f;
    f.open("Huffman.txt",ios::out);
    f<<"字符\t"<<"次数\t"<<"编码\t"<<endl;
    //输出时从1开始
    for(int i=1;i<chs.size();i++){
        if(chs[i].ch==' '){
            f<<"空格\t";
        }
        else if(chs[i].ch=='\n'){
            f<<"换行\t";
        }
        else{
            f<<chs[i].ch<<"\t";
        }
        f<<timesAppear[chs[i].ch]<<"\t";
        for(int j=0;j<chs[i].code.size();j++){
            f<<chs[i].code[j];
        }
        f<<"\t"<<endl;
    }
    f.close();
}
//选择两个最小权值点
pair<int,int> selectTwoSmall(int i){
    int min1=inf;
    int min2=inf;
    int num1=0;
    int num2=0;
    for(int j=1;j<i;j++){
        if(treeNodes[j].parent==0&&treeNodes[j].weight<min1){
            min1=treeNodes[j].weight;
            num1=j;
        }
    }
    for(int j=1;j<i;j++){
        if(treeNodes[j].parent==0&&treeNodes[j].weight<min2&&j!=num1){
            min2=treeNodes[j].weight;
            num2=j;
        }
    }
    return pair<int,int>{num1,num2};
}
//创建哈夫曼树函数
void createHuffmanTree(){
    //根据字符信息数组创建哈夫曼树节点数组
    int n=chs.size()-1;
    treeNodes.resize(2*n);//0号节点作废 多申请一个节点
    HTnode abandonNode;
    treeNodes[0]=abandonNode;
    for(int i=1;i<n+1;i++){
        HTnode newNode(timesAppear[chs[i].ch],0,0,0);
        treeNodes[i]=newNode;
    }
//    //测试
//    cout<<"weight\t"<<"parent\t"<<"lchild\t"<<"rchild\t"<<endl;
//    for(int i=1;i<n+1;i++){
//        cout<<treeNodes[i].weight<<"\t";
//        cout<<treeNodes[i].parent<<"\t";
//        cout<<treeNodes[i].lchild<<"\t";
//        cout<<treeNodes[i].rchild<<"\t";
//        cout<<endl;
//    }
    for(int i=n+1;i<2*n;i++){
        pair<int,int> twoSmallest;
        twoSmallest=selectTwoSmall(i);//注意此时返回的是两个最小数的编号
        int num1=twoSmallest.first;
        int num2=twoSmallest.second;
//        //测试
//        cout<<"选出两点编号为："<<endl;
//        cout<<num1<<" "<<num2<<endl;
//        cout<<"选出两点权值为："<<endl;
//        cout<<treeNodes[num1].weight<<" "<<treeNodes[num2].weight<<endl;
//        cout<<"选出两点字符为："<<endl;
//        cout<<chs[num1].ch<<" "<<chs[num2].ch<<endl;
        //修改两节点的双亲
        treeNodes[num1].parent=i;
        treeNodes[num2].parent=i;
        //初始化新节点
        treeNodes[i].lchild=num1;
        treeNodes[i].rchild=num2;
        treeNodes[i].weight=treeNodes[num1].weight+treeNodes[num2].weight;
        treeNodes[i].parent=0;
//        //测试
//        cout<<"weight\t"<<"parent\t"<<"lchild\t"<<"rchild\t"<<endl;
//        cout<<treeNodes[num1].weight<<"\t";
//        cout<<treeNodes[num1].parent<<"\t";
//        cout<<treeNodes[num1].lchild<<"\t";
//        cout<<treeNodes[num1].rchild<<"\t";
//        cout<<endl;
//        cout<<treeNodes[num2].weight<<"\t";
//        cout<<treeNodes[num2].parent<<"\t";
//        cout<<treeNodes[num2].lchild<<"\t";
//        cout<<treeNodes[num2].rchild<<"\t";
//        cout<<endl;
//        cout<<treeNodes[i].weight<<"\t";
//        cout<<treeNodes[i].parent<<"\t";
//        cout<<treeNodes[i].lchild<<"\t";
//        cout<<treeNodes[i].rchild<<"\t";
//        cout<<endl;
    }
}
//获取所有节点的哈夫曼编码 从叶到根获取编码存入栈中 然后用栈逆向读取即为编码
void getHuffmanCode(){
    int n=chs.size()-1;
    for(int i=1;i<n+1;i++){
        string str_code;
        stack<int> code;
        int nodeToCheck=i;
        while(treeNodes[nodeToCheck].parent!=0){
            int parentNode=treeNodes[nodeToCheck].parent;
            if(nodeToCheck==treeNodes[parentNode].lchild){
                code.push(0);
            }
            else{
                code.push(1);
            }
            //偏移
            nodeToCheck=parentNode;
        }
        //读入编码
        while(!code.empty()){
            chs[i].code.push_back(code.top());
            char str_c=code.top()+'0';
            str_code+=str_c;
            code.pop();
        }
        //建立由编码到字符的映射
        codeToCh[str_code]=chs[i].ch;
        //建立由字符到编码的映射
        chToCode[chs[i].ch]=chs[i].code;
    }
}
//将编码转换为比特位读入二进制文件
//方法：将所有编码存入一个数组中 然后每8位将其视为一个二进制数 转化为char类型后存储
void saveToDat(){
    fstream in;
    in.open("Huffman编码材料.txt",ios::in);
    fstream out;
    out.open("code.dat",ios::out|ios::binary);
    vector<int> allCodes;//存储所有编码
    char chToCheck;
    while(in.get(chToCheck)){
        for(int i=0;i<chToCode[chToCheck].size();i++){
            allCodes.push_back(chToCode[chToCheck][i]);
        }
    }
    int sum=0;
    for(int i=0;i<allCodes.size();i++){
        if(i%8==0&&i!=0){
            out<<(char)sum;
            sum=0;
        }
        sum+=pow(2,7-(i%8))*allCodes[i];
    }
    in.close();
    out.close();
}
//将十进制数转换为二进制数 存入数组对应位置中
//除二取余 倒序
void decToBin(int decNum,int *a){
    int currentPlace=7;//最先算出的余数应该放在最后
    while(decNum!=0){
        //先求余数
        a[currentPlace]=decNum%2;
        //再除以2
        decNum/=2;
        //再偏移
        currentPlace--;
    }
    //注意前面要补0
    for(int i=0;i<=currentPlace;i++){
        a[currentPlace]=0;
    }
}
//从二进制文件解码
//方法：每从文件中读取一个字符 首先将其转换为十进制 然后将其转换为二进制后存入数组中 从数组中依次读取编码进行解码
void deCodeFromDat(){
    fstream in;
    in.open("code.dat",ios::in);
    fstream out;
    out.open("recode.txt",ios::out);
    int a[inf];//存储所有解码
    char chToCheck;
    int currentPlace=0;//记录每一个二进制数的起始位
    while(in.get(chToCheck)){
        //注意不能将char型转换为有符号整型 要转换为无符号的整型才行
        int decNum=(chToCheck+256)%256;
        //如果chToCheck >= 0则结果为chToCheck本身 如果chToCheck < 0则会转化成其对应的无符号整型
        decToBin(decNum, a+currentPlace);
        currentPlace+=8;//每存一个二进制数要偏8位
    }
    //此时a中存储着所有的解码 用一个字符串逐一累加读取 遇到可解码的就解 然后字符串清空 重复该过程
    //此时的currentplace就是a中最后有效位的后一位
    string codeToCheck;
    for(int i=0;i<currentPlace;i++){
        char str_c=a[i]+'0';
        codeToCheck+=str_c;
//        cout<<codeToCheck<<endl;
        if(codeToCh.find(codeToCheck)!=codeToCh.end()){
            //如果找到了 就读取 然后字符串清零
            out<<codeToCh[codeToCheck];
            codeToCheck="";
        }
    }
    in.close();
    out.close();
}
int main(){
    calculateTimes();
    createHuffmanTree();
    getHuffmanCode();
    saveToTxt();
    saveToDat();
    deCodeFromDat();
    return 0;
}
```

#### 测试样例

+ 原文件

![yuanwenjian](/Users/plotnickslope/Desktop/截屏/截屏2023-01-16 14.39.51.png)

+ 编码展示文件

![bianma](/Users/plotnickslope/Desktop/截屏/截屏2023-01-16 14.41.09.png)

+ 二进制存储文件

![erjinzhi](/Users/plotnickslope/Desktop/截屏/截屏2023-01-16 14.42.39.png)

+ 解码文件

![jiema](/Users/plotnickslope/Desktop/截屏/截屏2023-01-16 14.43.14.png)

#### 算法时间复杂度

由于未采用堆优化，时间复杂度为O(n^2^)，其中n指所有字符的总个数

#### 代码行数

286

### 排序算法比较

#### 数据结构

```C++
clock_t startTime, finishTime;//储存起始与终止时间
double totalTime;//储存总的程序运行时间
vector<string> fileName;//存储每个数据文件的名称
vector<vector<int>> myData;//存储10组数据
const int N = 5e4 + 10;//开辟数组的大小
const int n = 5e4;//实际的每份数据量
```

数据来源是自己随机的10份样本数据

####算法设计思想

默认从小到大排序

+ 在各个排序中， 采用了各个排序算法的标准算法，但在以下部分中进行了改进：
  + 在冒泡排序中，加入了“如果在该趟冒泡中没有发生交换，即可break”的优化条件，原理是如果在某趟排序中没有发生交换，则所有数均满足前一个数比后一个小的条件，即数组已经有序，无序把后续的趟数走完。在这种方式下，若数据本身基本有序，则可大幅提高冒泡排序的速度
  + 在希尔排序中，没有采用静态间隔数组的形式取间隔，而是采用了资料上看到的动态间隔的方式，一定程度上降低了时间复杂度

#### 源代码

```C++
//本题默认所有的数据均采用从小到大排序
//其中样本1升序 样本10降序
#include<iostream>
#include<ctime>
#include<vector>
#include<string>
#include<fstream>
#include<cstdio>
using namespace std;

clock_t startTime, finishTime;//储存起始与终止时间
double totalTime;//储存总的程序运行时间
vector<string> fileName;//存储每个数据文件的名称
vector<vector<int>> myData;//存储10组数据
const int N = 5e4 + 10;//开辟数组的大小
const int n = 5e4;//实际的每份数据量

void sortStart(){
    //排序开始
    startTime = clock();
}

void sortFinish(){
    //排序结束
    finishTime = clock();
    totalTime = ((double)(finishTime - startTime) / CLOCKS_PER_SEC);
    cout << "排序时间为：" << totalTime << endl;
}

//快速排序
void quick_sort(int q[], int l, int r){
    if (l >= r) return;
    
    int i = l - 1, j = r + 1, x = q[(l + r) / 2];
    
    while (i < j){
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    
    quick_sort(q, l, j);
    quick_sort(q, j+1, r);
}

//归并排序
void merge_sort(int q[], int l, int r){
    if (l >= r) return;
    
    int mid = (l + r) / 2;
    
    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
    
    int tmp[N], k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r){
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r) tmp[k++] = q[j++];
    
    for (int i = l, j = 0; i <= r; i++, j++){
        q[i] = tmp[j];
    }
}

//冒泡排序（优化版本）
void bubble_sort(int q[], int n){
    for (int i = n - 1; i > 0; i--){
        bool flag = false;//表示该趟排序是否进行交换
        for (int j = 0; j <= i - 1; j++){
            if (q[j] > q[j + 1]){
                swap(q[j], q[j + 1]);
                flag = true;
            }
        }
        //如果做完该趟排序之后没有进行交换 表明已经有序
        if (!flag) break;
    }
}

//选择排序
void select_sort(int q[], int n){
    int index;//存储搜索到的最小元素的下标
    int myMin;//记录搜索到的最小值
    for (int i = 0; i < n - 1; i++){
        index = i;//假设最小值为第一个数
        myMin = q[i];
        //i表示的是当前应从哪个数开始往后搜索
        for (int j = i + 1; j < n; j++){
            if (q[j] < myMin){
                index = j;
                myMin = q[j];
            }
        }
        if (index != i) swap(q[i], q[index]);
    }
}

//插入排序
void insert_sort(int q[], int n){
    for (int i = 1; i < n; i++){
        int t = q[i], j; //从第2位开始取要插入的数 提前存储 防止被覆盖掉
        //此处的j还要在循环外使用 所以要提前声明
        for (j = i - 1; j >= 0; j--){
            if (q[j] > t){
                q[j + 1] = q[j];
            }
            else break; //如果已经比插入数小了一定要及时退出
        }
        //查找到合适的j之后 j + 1是插入位
        q[j + 1] = t;
    }
}

//希尔排序 采用动态间隔设置
void shell_sort(int q[], int n){
    int gap = 1;
    while (gap < n / 3){
        gap = 3 * gap + 1;
    }
    
    for (gap; gap > 0; gap /= 3){
        for (int i = gap; i < n; i++){
            int t = q[i], j;
            for (j = i - gap; j >= 0; j -= gap){
                if (q[j] > t) q[j + gap] = q[j];
                else break;
            }
            q[j + gap] = t;
        }
    }
}

//down操作
void down(int q[], int u, int length){
    int t = u;
    
    if (2 * u <= length && q[2 * u] > q[t]) t = 2 * u;
    if (2 * u + 1 <= length && q[2 * u + 1] > q[t]) t = 2 * u + 1;
    
    if (u != t){
        swap(q[u], q[t]);
        down(q, t, length);
    }
}

//堆排序
void heap_sort(int q[], int length){
    //将数组调整为大顶堆
    for (int i = length / 2; i; i--) down(q, i, length);
    
    int n = length; //n用来记录循环的次数 也是对length的备份
    
    for (int i = 0; i < n; i++){
        swap(q[1], q[length]); //将最大的数放到最后面
        length--; //删除最大数
        down(q, 1, length);
    }
    
    //如上操作后 从编号为1的元素开始输出 即为升序
}

//取第i位数函数
//i=0时表示个位, i=1时表示十位, ...
int get(int x, int i){
    while (i--) x /= 10;
    return x %= 10;
}

//基数排序
void radix_sort(int q[], int n){
    vector<vector<int>> cnt(10);//创建10个桶
    
    //由于数据最多为5位数 所以最多只需要进行5次基数排序即可
    for (int i = 0; i < 5; i++){
        //每次开始前都需要将桶清空
        for (int j = 0; j < 10; j++) cnt[j].clear();
        
        for (int j = 0; j < n; j++){
            cnt[get(q[j], i)].push_back(q[j]);
        }
        
        //将桶中数据转移回原数组
        for (int j = 0, k = 0; j < 10; j++){
            for (int x : cnt[j]){
                q[k++] = x;
            }
        }
    }
}

int main(){
    for (int i = 1; i <= 9; i++){
        char char_i = i + '0';
        string nameToPush = "sample";
        nameToPush += char_i;
        nameToPush += ".txt";
        fileName.emplace_back(nameToPush);
    }
    fileName.emplace_back("sample10.txt");

    //读入数据
    myData.resize(10);
    for (int i = 0; i < 10; i ++){
        fstream f;
        f.open(fileName[i], ios::in);
        if (!f.is_open()){
            cout << "数据文件打开失败" <<endl;
            exit(0);
        }

        int num;
        while (f >> num){
            myData[i].emplace_back(num);
        }
    }

    //排序
    for (int i = 0; i < 10; i++){
        cout << fileName[i] << ':' << endl;

        //每次先将数据读入数组中 避免传递参数时改变原数据和复制量太大的问题
        int q[N];

        for (int j = 0; j < n; j++){
            q[j] = myData[i][j];
        }
        //快速排序
        sortStart();
        quick_sort(q, 0, n - 1);
        cout << "快速排序";
        sortFinish();

        for (int j = 0; j < n; j++){
            q[j] = myData[i][j];
        }
        //归并排序
        sortStart();
        merge_sort(q, 0, n - 1);
        cout << "归并排序";
        sortFinish();

        for (int j = 0; j < n; j++){
            q[j] = myData[i][j];
        }
        //冒泡排序
        sortStart();
        bubble_sort(q, n);
        cout << "冒泡排序";
        sortFinish();

        for (int j = 0; j < n; j++){
            q[j] = myData[i][j];
        }
        //选择排序
        sortStart();
        select_sort(q, n);
        cout << "选择排序";
        sortFinish();

        for (int j = 0; j < n; j++){
            q[j] = myData[i][j];
        }
        //插入排序
        sortStart();
        insert_sort(q, n);
        cout << "插入排序";
        sortFinish();

        for (int j = 0; j < n; j++){
            q[j] = myData[i][j];
        }
        //希尔排序
        sortStart();
        shell_sort(q, n);
        cout << "希尔排序";
        sortFinish();

        //堆排序前创建数组时注意从1开始编号
        for (int j = 1; j <= n; j++){
            q[j] = myData[i][j];
        }
        //堆排序
        sortStart();
        heap_sort(q, n);
        cout << "堆排序";
        sortFinish();
        
        for (int j = 0; j < n; j++){
            q[j] = myData[i][j];
        }
        //基数排序
        sortStart();
        radix_sort(q, n);
        cout << "基数排序";
        sortFinish();
    }
    
    return 0;
}
```

#### 测试样例

由于随机样本数据量太大，此处只展示排序所用时间的结果，其中sample1为升序，sample10为降序

![截图1](/Users/plotnickslope/Desktop/截屏/截屏2023-01-15 23.34.30.png)

![jietu2](/Users/plotnickslope/Desktop/截屏/截屏2023-01-15 23.34.36.png)

![jietu3](/Users/plotnickslope/Desktop/截屏/截屏2023-01-15 23.34.42.png)

![jietu4](/Users/plotnickslope/Desktop/截屏/截屏2023-01-15 23.34.44.png)

#### 算法时间复杂度

|   算法   |    复杂度     |
| :------: | :-----------: |
| 快速排序 | O(nlog~2~^n^) |
| 归并排序 | O(nlog~2~^n^) |
| 冒泡排序 |    O(n^2^)    |
| 选择排序 |    O(n^2^)    |
| 插入排序 |    O(n^2^)    |
| 希尔排序 |   O(n^1.3^)   |
|  堆排序  | O(nlog~2~^n^) |
| 基数排序 | O(dn) d为位数 |

#### 代码行数

301

## 选做题

### 棋局评估

#### 数据结构

```C++
vector<vector<vector<int>>> chessBoard; //存储所有的棋盘
```

#### 算法设计思想

由于输入时下一个一定是A下棋 所以不存在B再下一个就赢的情况

输入的棋局只有可能出现四种情况

1. A再下一个就赢

2. B已经赢了

3. A已经赢了

4. 不满足上述条件 由于默认双方都采用最优策略 则一定平局

+ 判断赢家

  不判断格子数 采用计算数字和的方式来判断

  分别求出 每行 每列 每个对角线的和 判断是否存在赢的情况

  1. 求出来是6 B赢了

  2. 求出来是3 且求和的数中没有0 A赢了（一定是3个一的情况）

  3. 求出来是2 且求和的数中没有2 A已经赢了（一定是110的情况 再下一个就赢）

  不满足上述任何条件 必然平局

+ 统计分数

  遍历棋盘统计空格数 然后按照题目给出的计算方法计算即可

#### 源代码

```C++
//由于输入时下一个一定是A 所以不存在B再下一个就赢的情况
//输入的棋局只有可能出现四种情况
//1.A再下一个就赢
//2.B已经赢了
//3.A已经赢了
//4.不满足上述条件 由于默认双方都采用最优策略 则一定平局
//算法：不判断格子 而采用求和的方式来判断是否存在符合要求的情况
//分别求出 每行 每列 每个对角线的和 判断是否存在赢的情况
//1.求出来是6 B赢了
//2.求出来是3 且求和的数中没有0 A赢了（一定是3个一的情况）
//3.求出来是2 且求和的数中没有2 A已经赢了（一定是110的情况 再下一个就赢）
//不满足上述任何条件 必然平局
#include<iostream>
#include<vector>
using namespace std;

vector<vector<vector<int>>> chessBoard; //存储所有的棋盘

//判断每一行
//-1表示没判断出来 1表示A已经赢了 2表示A差一步赢 3表示B赢了
int checkEachRow(int currentBoard){
    for(int i=0;i<3;i++){
        int sum;
        sum=chessBoard[currentBoard][i][0]+chessBoard[currentBoard][i][1]+chessBoard[currentBoard][i][2];
        if(sum==6){
            return 3;
        }
        else if(sum==3){
            if(chessBoard[currentBoard][i][0]!=0&&chessBoard[currentBoard][i][1]!=0&&chessBoard[currentBoard][i][2]!=0){
                return 2;
            }
        }
        else if(sum==2){
            if(chessBoard[currentBoard][i][0]!=2&&chessBoard[currentBoard][i][1]!=2&&chessBoard[currentBoard][i][2]!=2){
                return 1;
            }
        }
    }
    //若上述三种情况都不满足 表示没判断出来 返回-1
    return -1;
}

//判断每一列
//-1表示没判断出来 1表示A已经赢了 2表示A差一步赢 3表示B赢了
int checkEachCol(int currentBoard){
    for(int i=0;i<3;i++){
        int sum;
        sum=chessBoard[currentBoard][0][i]+chessBoard[currentBoard][1][i]+chessBoard[currentBoard][2][i];
        if(sum==6){
            return 3;
        }
        else if(sum==3){
            if(chessBoard[currentBoard][0][i]!=0&&chessBoard[currentBoard][1][i]!=0&&chessBoard[currentBoard][2][i]!=0){
                return 2;
            }
        }
        else if(sum==2){
            if(chessBoard[currentBoard][0][i]!=2&&chessBoard[currentBoard][1][i]!=2&&chessBoard[currentBoard][2][i]!=2){
                return 1;
            }
        }
    }
    //若上述三种情况都不满足 表示没判断出来 返回-1
    return -1;
}

//判断两条对角线 1表示A已经赢了 2表示A差一步赢 3表示B赢了
int checkDiagonal(int currentBoard){
    int sum1=chessBoard[currentBoard][0][0]+chessBoard[currentBoard][1][1]+chessBoard[currentBoard][2][2];
    int sum2=chessBoard[currentBoard][0][2]+chessBoard[currentBoard][1][1]+chessBoard[currentBoard][2][0];
    if(sum1==6){
        return 3;
    }
    else if(sum1==3){
        if(chessBoard[currentBoard][0][0]!=0&&chessBoard[currentBoard][1][1]!=0&&chessBoard[currentBoard][2][2]!=0){
            return 2;
        }
    }
    else if(sum1==2){
        if(chessBoard[currentBoard][0][0]!=2&&chessBoard[currentBoard][1][1]!=2&&chessBoard[currentBoard][2][2]!=2){
            return 1;
        }
    }
    if(sum2==6){
        return 3;
    }
    else if(sum2==3){
        if(chessBoard[currentBoard][0][2]!=0&&chessBoard[currentBoard][1][1]!=0&&chessBoard[currentBoard][2][0]!=0){
            return 2;
        }
    }
    else if(sum2==2){
        if(chessBoard[currentBoard][0][2]!=2&&chessBoard[currentBoard][1][1]!=2&&chessBoard[currentBoard][2][0]!=2){
            return 1;
        }
    }
    return -1;
}

//返回值表示胜者 0表示平局 1表示A已经赢了 2表示A差一步赢 3表示B赢了
int whoIsTheWinner(vector<vector<vector<int>>> &chessBoard,int currentBoard){
    //分别求出 每行 每列 每个对角线的和 判断是否存在赢的情况
    //1.求出来是6 B赢了
    //2.求出来是3 且求和的数中没有0 A赢了（一定是3个一的情况）
    //3.求出来是2 且求和的数中没有2 A已经赢了（一定是110的情况 再下一个就赢）
    //不满足上述任何条件 必然平局 返回0
    int flag=checkEachRow(currentBoard);
    if(flag!=-1){
        return flag;
    }
    else{
        flag=checkEachCol(currentBoard);
    }
    if(flag!=-1){
        return flag;
    }
    else{
        flag=checkDiagonal(currentBoard);
    }
    if(flag!=-1){
        return flag;
    }
    else{
        return 0;
    }
}

//计算分数函数
//注意：对A 如果是在行棋之后才会赢 返回的是行棋之后剩余的空白格子数+1 也就是未行棋之前的剩余空白格子数 所以这种情况直接返回空白格子数就可以了
int calculateScore(vector<vector<vector<int>>> &chessBoard,int currentBoard,int winner){
    if(winner==0){
        return 0;
    }
    //如果上面没有返回 首先统计共有多少个0
    int numOfSpaceBlocks=0;
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(chessBoard[currentBoard][i][j]==0){
                numOfSpaceBlocks++;
            }
        }
    }
    if(winner==1){
        return numOfSpaceBlocks;//差一步赢 直接返回空白格子数即可
    }
    else if(winner==2){
        return numOfSpaceBlocks+1;
    }
    else{
        return -(numOfSpaceBlocks+1);
    }
}

int main(){
    int t;//表示数据组数
    cin>>t;
    chessBoard.resize(t);
    for(int i=0;i<t;i++){
        chessBoard[i].resize(3);
        for(int j=0;j<3;j++){
            chessBoard[i][j].resize(3);
        }
    }
    //初始化t个九宫格
    //输入
    for(int i=0;i<t;i++){//i表示棋盘整体的编号
        for(int j=0;j<3;j++){//j表示某具体棋盘的行号
            for(int k=0;k<3;k++){//k表示某具体棋盘的列号
                int x;
                cin>>x;
                chessBoard[i][j][k]=x;
            }
        }
    }
    //分别判断每个棋盘 并在单次判断完后输出结果
    for(int i=0;i<t;i++){
        int winner=whoIsTheWinner(chessBoard, i);
        int score=calculateScore(chessBoard, i, winner);
        cout<<score<<endl;
    }
    return 0;
}
```

#### 测试样例

![qiju](/Users/plotnickslope/Desktop/截屏/截屏2023-01-19 15.59.40.png)

#### 算法时间复杂度

判断赢家 O(n^2^)

#### 代码行数

182

### URL映射

####数据结构

```C++
//创建正则替换表 使用R"()"的格式避免了冗杂的转义 直接输入原字符串即可
//需要保证匹配到的字符串非空 所以为+
vector<pair<regex,string>> trans={
    {regex("<int>"),R"((\d+))"},
    {regex("<str>"),R"((\w+))"},
    {regex("<path>"),R"((.+))"}
    //注意此处 R"(……)"的内部一定还要加括号 才能够表示分组 匹配输出时才能够输出各个子组的匹配结果
    //如果不加（）分组 匹配的结果中只会有匹配的整体 而不会有各个子组的匹配内容
};
//创建哈希表存储规则字符串到其正则表达式的映射
map<string,regex> rules;
//创建数组存储所有的地址
vector<string> addresses;
```

#### 算法设计思想

核心是利用STL中的`regex`库，是用正则表达式进行匹配

1. 预先设置好正则表达式的替换规则`trans`，在读入时就将匹配符替换为响应含义的正则表达式，然后将替换后的字符串转为正则表达式存入`rule`
2. 对每一条传入的地址进行正则匹配
3. 输出结果，需要注意如果匹配结果中出现了数字，要用`string`库中的`stoi`函数将字符串转化为数字，然后再输出

#### 源代码

```C++
//最简单的做法是使用C++中的正则表达式 需要包含regex库
//只有重载了<的类才可以作为map中的键 而regex没有 所以不可以直接作为map的类
//避免在正则表达式中使用//的方法：R"(……)" 在省略号中按一般方式书写即可 这种式子可以被识别为字符串
#include<iostream>
#include<string>
#include<vector>
#include<regex>
#include<map>
using namespace std;
//创建正则替换表 使用R"()"的格式避免了冗杂的转义 直接输入原字符串即可
//需要保证匹配到的字符串非空 所以为+
vector<pair<regex,string>> trans={
    {regex("<int>"),R"((\d+))"},
    {regex("<str>"),R"((\w+))"},
    {regex("<path>"),R"((.+))"}
    //注意此处 R"(……)"的内部一定还要加括号 才能够表示分组 匹配输出时才能够输出各个子组的匹配结果
    //如果不加（）分组 匹配的结果中只会有匹配的整体 而不会有各个子组的匹配内容
};
//创建哈希表存储规则字符串到其正则表达式的映射
map<string,regex> rules;
//创建数组存储所有的地址
vector<string> addresses;
//特殊匹配转化函数 提供一个转化表 将原字符串中的匹配符转化为正则表达式中的匹配符
string transportToRegex(string s){
    for(auto it=trans.begin();it!=trans.end();it++){
        s=regex_replace(s,it->first,it->second);
        //现将正则表达式匹配的内容变为指定的字符串
    }
    return s;
}
bool checkIfNumber(string s){
    for(int i=0;i<s.size();i++){
        if(s[i]<'0'||s[i]>'9'){
            //检测到 非数字
            return false;
        }
    }
    //若循环完还没有返回 说明没有非数字字符
    return true;
}
int main(){
    int n,m;
    cin>>n>>m;
    //输入规则
    for(int i=0;i<n;i++){
        string rule,ruleName;
        cin>>rule>>ruleName;
        rule=transportToRegex(rule);
        //此时的s还是字符串 加入rules时注意转化为匿名正则匹配表达式
        rules[ruleName]=regex(rule);
    }
    //输入地址
    for(int i=0;i<m;i++){
        string address;
        cin>>address;
        addresses.push_back(address);
    }
    //开始比对
    for(int i=0;i<m;i++){
        //创建比对结果对象
        smatch rst;
        //对每一条规则依次比对
        for(auto it=rules.begin();it!=rules.end();it++){
            if(regex_match(addresses[i],rst,it->second)){
                //如果有一条比对成功 输出比对结果后可以直接进行下一条的比对
                cout<<it->first<<" ";
                //注意如果是<int>类型 需要先转化为数字后输出（去掉前面的0）
                for(int i=1;i<rst.size();i++){
                    //注意rst的第一项是匹配的整体 后面才是子组的内容
                    //在输出前判断一下该子组是不是数字类型 如果是 转换为数字后再输出
                    if(checkIfNumber(rst[i].str())){
                        int ansNumber=stoi(rst[i].str());
                        cout<<ansNumber<<" ";
                    }
                    else{
                        cout<<rst[i].str()<<" ";
                    }
                }
                cout<<endl;//输出完一次匹配后换行
                break;
            }
        }
        //如果比对结果为空 说明没匹配出来 输出404
        if(rst.empty()){
            cout<<"404"<<endl;
        }
    }
    return 0;
}
```

#### 测试样例

![](/Users/plotnickslope/Desktop/截屏/截屏2023-01-19 22.44.59.png)

#### 算法时间复杂度

+ 将规则转为正则表达式`O(n)`
+ 对地址比对输出`O(nm)`

#### 代码行数

89

### 连连看

#### 数据结构

```C++
vector<vector<int>> board; //游戏面板
//创建坐标集合 用于随机
vector<pair<int,int>> placesAvailable;
```

#### 算法设计思想

分别判定每种可能的消除情况

+ 如果指定两点都在游戏界面的边界上 则可直接认为是三段线消除
+ 如果指定两点横坐标或纵坐标相同 检查在两者连线上是否存在图案 如果没有 则可认为是一段线消除
+ 如果不满足上述两种情况 检查两点横纵坐标所延伸形成的两个交汇点与两点是否都满足一段线消除 如果满足 则可认为是二段线消除
+ 如果不满足上述三种情况 检查两点其中一点横纵坐标延伸的点上是否存在点与另一指定点满足二段线消除 如果满足 则可认为是三段线消除

#### 源代码

```C++
//算法：分别判定每种可能的消除情况
//-1表示没有图案 0-9分别表示十种图案
//游戏界面长20 宽10
#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
#include<ctime>
using namespace std;

vector<vector<int>> board; //游戏面板
//创建坐标集合 用于随机
vector<pair<int,int>> placesAvailable;

void printBoard(){
    //输出最上层的坐标提示
    cout<<"\t"<<"\t";
    for(int i=1;i<21;i++){
        cout<<i<<"\t";
    }
    cout<<endl;
    //输出游戏界面
    for(int i=0;i<12;i++){
        for(int j=0;j<22;j++){
            //注意每行开头和结尾还要输出坐标提示
            if(j==0){
                //最前面
                if(i==0||i==11){
                    //最上和最下的两行
                    cout<<"\t";
                }
                else{
                    //中间行
                    //先输出提示
                    cout<<i<<"\t";
                }
                //再输出第一个数
                cout<<board[i][j]<<"\t";
            }
            else if(j==21){
                //最后面
                //先输出最后一个数
                cout<<board[i][j]<<"\t";
                //再根据情况输出提示
                if(i==0||i==11){
                    //最上和最下的两行
                    cout<<"\t";
                }
                else{
                    //中间行
                    cout<<i<<"\t";
                }
            }
            else{
                //不是每行开头和结尾 直接输出
                cout<<board[i][j]<<"\t";
            }
        }
        cout<<endl;
    }
    //输出最下层的坐标提示
    cout<<"\t"<<"\t";
    for(int i=1;i<21;i++){
        cout<<i<<"\t";
    }
    cout<<endl;
}
bool checkIfZeroAngleOK(int x1,int y1,int x2,int y2){
    //注意 要考虑到可以用外面空间删除的情况
    bool flag=true;
    if(x1==x2){
        //如果未到达边界
        //如果横向相等 检查两者纵向之间是否有图案存在
        int startY=min(y1,y2);
        int endY=max(y1,y2);
        for(int i=startY+1;i<endY;i++){
            cout<<board[i][x1]<<endl;
            if(board[i][x1]!=-1){
                //只要存在一个图案 就不不满足情况 无需继续判断
                flag=false;
                break;
            }
        }
    }
    else{
        //如果纵向相等 检查两者横向之间是否有图案存在
        int startX=min(x1,x2);
        int endX=max(x1,x2);
        for(int i=startX+1;i<endX;i++){
            cout<<board[y1][i]<<endl;
            if(board[y1][i]!=-1){
                //只要存在一个图案 就不不满足情况
                flag=false;
                break;
            }
        }
    }
    if(flag==true){
        return true;
    }
    //如果前面都没有返回 说明两个标志都为假 可以返回假
    return false;
}
bool checkIfOneAngleOk(int x1,int y1,int x2,int y2){
    //检查两点交汇处的两点是否满足题意
    //首先找到两个交汇点 然后依次检查这两点与AB是否满足单线相连
    //(x1,y2) (x2,y1)
    bool f1,f2;//分别表示交汇点与AB是否满足单线相连的标志
    f1=checkIfZeroAngleOK(x1,y1,x1,y2);//第一个交汇点与A
    //如果为真 可以继续判断B 如果为假 直接判断下一个交汇点
    if(f1==true){
        f2=checkIfZeroAngleOK(x2, y2, x1, y2);
        //如果f2也为真 直接返回真 否则进行第二个交汇点的判断
        if(f2==true){
            return true;
        }
    }
    //若前面没有返回 说明第一个交汇点不满足 判断第二个交汇点
    f1=checkIfZeroAngleOK(x1, y1, x2, y1);
    if(f1==true){
        f2=checkIfZeroAngleOK(x2, y2, x2, y1);
        if(f2==true){
            return true;
        }
    }
    //如果前面都没有返回 说明不满足
    return false;
}
bool checkIfTwoAngleOk(int x1,int y1,int x2,int y2){
    //以A为基准点 依次检查A的横向与纵向在范围内的点是否满足与B两线相连(只需检查两者围成矩形的一半边即可)
    //不需要所有点都满足与B可以两线相连 只要有一个就可以了
    //先检查横向
    int startX=min(x1,x2);
    int endX=max(x1,x2);
    for(int i=startX+1;i<endX;i++){
        bool flag=checkIfOneAngleOk(x2, y2, i, y1);
        if(flag==true){
            return true;
        }
    }
    //若横向没有返回真 就检查纵向
    int startY=min(y1,y2);
    int endY=max(y1,y2);
    for(int i=startY+1;i<endY;i++){
        bool flag=checkIfOneAngleOk(x2, y2, x1, i);
        if(flag==true){
            return true;
        }
    }
    //若前面都没有找到返回真的点 就返回假
    return false;
}
bool checkIfOk(int x1,int y1,int x2,int y2){
    //根据连线的段数分类讨论
    bool flag;
    if(x1==x2||y1==y2){
        if((x1==1||x1==20) && x1==x2){
            cout<<"三段线消除"<<endl;
            return true;
        }
        if((y1==1||y1==10) && y1==y2){
            cout<<"三段线消除"<<endl;
            return true;
        }
        //1.一段 在同行或同列 且中间没有图案
        flag=checkIfZeroAngleOK(x1, y1, x2, y2);
        if(flag==true){
            cout<<"一段线消除"<<endl;
            return true;
        }
    }
    //如果进行到下面 说明不满足一段
    else{
        //2.二段
        flag=checkIfOneAngleOk(x1, y1, x2, y2);
        if(flag==true){
            cout<<"二段线消除"<<endl;
            return true;
        }
        //如果进行到下面 说明不满足一段和二段
        //3.三段
        flag=checkIfTwoAngleOk(x1, y1, x2, y2);
        if(flag==true){
            cout<<"三段线消除"<<endl;
            return true;
        }
    }
    return false;
}
int main(){
    //由于还需要考虑可以从方格图外相连的情况 所以规定空间时规定为22*12的空间 此时坐标是与索引直接对应的
    board.resize(12);
    //初始化 把所有数据都初始化为-1
    for(int i=0;i<12;i++){
        board[i].resize(22,-1);
    }
    for(int i=1;i<11;i++){
        for(int j=1;j<21;j++){
            placesAvailable.emplace_back(i,j);
        }
    }
    srand((unsigned int)time(NULL));
    //随机图案
    for(int i=0;i<10;i++){
        //0-9表示的是不同图案
        //一共有200个位置放置图案 共10种图案 每种图案分配20个位置
        //确定个数后 为每个图案随机坐标
        for(int j=0;j<20;j++){
            //随机出一个索引 然后在placesAvailable中挑出该索引所对的值
            int index=rand()%(placesAvailable.size());
            int x,y;
            x=placesAvailable[index].first;
            y=placesAvailable[index].second;
            board[x][y]=i;
            //注意在赋值完后要将该坐标从可用坐标中删除
            placesAvailable.erase(placesAvailable.begin()+index);
        }
    }
    cout<<"-1表示没有图案的点"<<endl;
    cout<<"左上角图案的坐标为（1，1） 向右x增大 向下y增大"<<endl;
    //记录剩余的图案数 用于确定游戏何时终止
    int patternsLeft=200;
    //开始玩游戏
    while(patternsLeft!=0){
        //行数==纵坐标
        //列数==横坐标
        //传入给检查函数的是坐标
        cout<<"您当前的游戏界面为"<<endl;
        printBoard();
        cout<<"请依次输入两个点的横坐标和纵坐标:"<<endl;
        cout<<"第一个点："<<endl;
        int x1,y1;
        cin>>x1>>y1;
        cout<<"第二个点："<<endl;
        int x2,y2;
        cin>>x2>>y2;
        if(x1==x2&&y1==y2){
            cout<<"不能输入相同点 请重新输入"<<endl;
            continue;
        }
        if(board[y1][x1]!=board[y2][x2]){
            cout<<"两点图案不同 无法消除"<<endl;
            continue;
        }
        if(x1<1||x1>20||x2<1||x2>20||y1<1||y1>10||y2<1||y2>10){
            cout<<"坐标超限 请重新输入"<<endl;
            continue;
        }
        //输入满足要求 开始游戏
        bool flag=checkIfOk(x1, y1, x2, y2);
        if(flag==true){
            //删除点
            board[y1][x1]=-1;
            board[y2][x2]=-1;
            //剩余图案数量-2
            patternsLeft-=2;
            cout<<"两点相消成功"<<endl;
        }
        else{
            cout<<"两点相消失败"<<endl;
        }
    }
    return 0;
}
```

#### 测试样例

![yangli1](/Users/plotnickslope/Desktop/截屏/截屏2023-01-20 09.52.35.png)

![yangli2](/Users/plotnickslope/Desktop/截屏/截屏2023-01-20 09.52.37.png)

#### 算法时间复杂度

+ 一段线和二段线的判断 O(n)
+ 三段线的判断 O(n^2^)

#### 代码行数

264

### 电子小词典

#### 数据结构

本题采用了Trie树的数据结构对单词进行存储

```C++
const int N = 1e6 + 10; //该微型字典存储单词的总长度不超过1e6

int son[N][26], idx = 0; //son数组存储了各个编号的节点的子节点 idx表示当前可用的编号
vector<bool> ifWord; //表示在Trie树的某节点处是否存在单词
vector<string> meanings; //存储单词的解释 下标即为编号
int cnt = 0; //存储的总单词数
vector<char> path; //存储DFS过程中的路径
```

#### 算法设计思想

+ 在单词的添加和查询上 采用了Trie树（字典树）的数据结构进行操作 从头遍历单词的每个字母 没有某子节点就创建某子节点 有对应子节点则沿子节点延伸 直至所有字母全部存储完毕
+ 在单词的删除上 并没有实际删除 而是新开了一个布尔数组表示在某节点处是否存在以该节点结尾的单词 删除时直接更改布尔值即可
+ 修改操作采用前面删除与添加组合的方式实现
+ 在遍历所有单词时 采用了DFS记录路径的方法

#### 源代码

```C++
//采用Trie树结构来完成字典任务
#include<iostream>
#include<string>
#include<vector>
#include<fstream>
using namespace std;

const int N = 1e6 + 10; //该微型字典存储单词的总长度不超过1e6

int son[N][26], idx = 0;
vector<bool> ifWord;
vector<string> meanings; //存储单词的解释 下标即为编号
int cnt = 0; //存储的总单词数
vector<char> path; //存储DFS过程中的路径

//添加单词
void insert(string &str, string &meaning){
    int p = 0;
    
    for (int i = 0; i < str.size(); i++){
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    
    ifWord[p] = true;
    meanings[p] = meaning;
    cnt++;
}

//查询单词意思
string query(string &str){
    int p = 0;
    
    for (int i = 0; i < str.size(); i++){
        int u = str[i] - 'a';
        if (!son[p][u]) return "查询单词不存在";
        p = son[p][u];
    }
    
    //即使找到了单词也要确认一遍ifWord
    if (ifWord[p]) return meanings[p];
    else return "查询单词不存在";
}

//删除单词
void removeWord(string &str){
    int p = 0;
    
    for (int i = 0; i < str.size(); i++){
        int u = str[i] - 'a';
        if (!son[p][u]){
            cout << "查询单词不存在" << endl;
            return;
        }
        p = son[p][u];
    }
    
    if (ifWord[p]){
        ifWord[p] = false;
        cnt--;
    }
    else cout << "查询单词不存在" <<endl;
}

//修改单词
void modify_word(string &oldWord, string &newWord){
    string meaning = query(oldWord);
    removeWord(oldWord);
    insert(newWord, meaning);
}

//修改单词意思
void modify_meaning(string &str, string &newMeaning){
    int p = 0;
    
    for (int i = 0; i < str.size(); i++){
        int u = str[i] - 'a';
        if (!son[p][u]) {
            cout << "查询单词不存在" << endl;
            return;
        }
        p = son[p][u];
    }
    
    //即使找到了单词也要确认一遍ifWord
    if (ifWord[p]) meanings[p] = newMeaning;
    else{
        cout << "查询单词不存在" << endl;
        return;
    }
}

//修改单词和意思
void modify(string &oldWord, string &newWord, string &newMeaning){
    removeWord(oldWord);
    insert(newWord, newMeaning);
}

//读取文件函数
void readFromFiles(){
    fstream f;
    f.open("单词表.txt", ios::in);
    if (!f.is_open()){
        cout << "文件读取失败" << endl;
        exit(0);
    }
    
    int num;
    f >> num; //记录数
    for (int i = 0; i < num; i++){
        string word;
        f >> word;
        string meaning;
        f >> meaning;
        insert(word, meaning);
    }
    
    cout << "读入数据成功" << endl;
    cout << "当前存有单词" << cnt << "个" << endl;
}

void DFS(int u, char currentCh, fstream &f){
    if (!u) return;
    
    path.push_back(currentCh);
    //检查当前位是否存在单词
    if (ifWord[u]){
        string word;
        for (char ch : path){
            word += ch;
        }
        string meaning;
        meaning = meanings[u];
        f << word << ' ' << meaning << ' ' << endl;
    }
    for (int i = 0; i < 26; i++){
        DFS(son[u][i], i + 'a', f);
    }
    path.pop_back();
}

//写入文件函数
void writeIntoFiles(){
    fstream f;
    f.open("单词表.txt", ios::out);
    
    f << cnt << endl;
    
    for (int i = 0; i < 26; i++){
        DFS(son[0][i], i + 'a', f);
    }
}

int main(){
    meanings.resize(N);
    ifWord.resize(N, false);
    
    readFromFiles();
    
    while (1){
        cout << "欢迎使用电子词典系统" << endl;
        cout << "请输入您的选择：" << endl;
        cout << "1. 添加单词" << endl;
        cout << "2. 查询单词" << endl;
        cout << "3. 删除单词" << endl;
        cout << "4. 修改单词" << endl;
        cout << "0. 退出词典" << endl;
        int choice;
        cin >> choice;
        if (choice == 1){
            cout << "请输入您要添加的单词" << endl;
            string word;
            cin >> word;
            cout << "请输入添加单词的意思" << endl;
            string meaning;
            cin >> meaning;
            insert(word, meaning);
        }
        else if (choice == 2){
            cout << "请输入您要查询的单词" << endl;
            string word;
            cin >> word;
            cout << query(word) << endl;
        }
        else if (choice == 3){
            cout << "请输入您要删除的单词" << endl;
            string word;
            cin >> word;
            removeWord(word);
        }
        else if (choice == 4){
            cout << "请输入您的修改方式：" <<endl;
            cout << "1. 仅修改单词" << endl;
            cout << "2. 仅修改意思" << endl;
            cout << "3. 修改单词和意思" << endl;
            cout << "按其他键返回菜单" << endl;
            int way;
            cin >> way;
            if (way == 1){
                cout << "请输入您要修改的原单词" << endl;
                string oldWord;
                cin >> oldWord;
                cout << "请输入新单词" << endl;
                string newWord;
                cin >> newWord;
                modify_word(oldWord, newWord);
            }
            else if (way == 2){
                cout << "请输入您要修改的原单词" << endl;
                string word;
                cin >> word;
                cout << "请输入新意思" << endl;
                string meaning;
                cin >> meaning;
                modify_meaning(word, meaning);
            }
            else if (way == 3){
                cout << "请输入您要修改的原单词" << endl;
                string oldWord;
                cin >> oldWord;
                cout << "请输入新单词" << endl;
                string newWord;
                cin >> newWord;
                cout << "请输入新意思" << endl;
                string meaning;
                cin >> meaning;
                modify(oldWord, newWord, meaning);
            }
        }
        else if (choice == 0){
            writeIntoFiles();
            exit(0);
        }
        else{
            cout << "您输入有误 请重新输入" <<endl;
        }
    }
    return 0;
}
```

#### 测试样例

本程序最终将单词表读入文件中

![截屏2023-01-22 23.15.30](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-22 23.15.30.png)

![截屏2023-01-22 23.15.50](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-22 23.15.50.png)

在单词表为空的情况下读入数据 添加了boy cake data三个单词 然后删除了boy 最终在文件中呈现的结果如下

![截屏2023-01-22 23.15.07](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-22 23.15.07.png)

重新读入文件后查询效果如图

![截屏2023-01-22 23.17.46](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-22 23.17.46.png)

#### 算法时间复杂度

由于使用了Trie树的数据结构 时间复杂度为`O(n)` 其中n指单词长度

#### 代码行数

240

### 哈希表应用：VIP客户发掘

#### 数据结构

由于本题分别要求用开放寻址法和拉链法求解 所以在此分别列出两种方法的数据结构

> 拉链法

```C++
const int N = 47; //取一个质数 且离32与64较远 冲突概率比较低

class guest{
public:
    long long id; //身份证
    string name; //姓名
    int freq; //频率
    int dis; //里程
    
    guest(long long id, string name){
        this->id = id;
        this->name = name;
        freq = 0;
        dis = 0;
    }
    
    guest(){
        
    }
};
vector<long long> ids; //存储所有的身份证号 便于后续统计
int cnt = 0; //记录发生冲突的次数
int h[N], ne[N], idx = 0;
//h哈希表 ne为指向下一个节点的指针 idx表示当前可用的编号
guest e[N]; //存储客户信息
```

> 开放寻址法

```C++
const int N = 97; //开放寻址法的空间一般要开到原长的两到三倍 且要取一个里2的整次幂较远的质数

class guest{
public:
    long long id; //身份证
    string name; //姓名
    int freq; //频率
    int dis; //里程
    
    guest(long long id, string name){
        this->id = id;
        this->name = name;
        freq = 0;
        dis = 0;
    }
    
    guest(){
        id = -1;
        //默认初始化时将id初始化为-1 表示当前位没有存储客户信息
    }
};
vector<long long> ids; //存储所有的身份证号 便于后续统计
int cnt = 0; //记录发生冲突的次数
vector<int> times; //记录每一次发生冲突都发生了多少次重定位
guest h[N];
//h哈希表
```

#### 算法设计思想

+ 对于拉链法 将所有经哈希函数映射后冲突的数据存储到一个链表中 整个哈希表中存储的是数据的指针
+ 对于开放寻址法 类似于厕所蹲坑 如果经哈希函数映射后发现对应的坑位有人了 就往下一个坑位找 直到找到没有人的坑位为止

#### 源代码

> 拉链法

```C++
//拉链法不存在重定位的问题 只需要统计发生冲突的次数
#include<iostream>
#include<vector>
#include<string>
#include<fstream>
#include<cstring>
using namespace std;

const int N = 47; //取一个质数 且离32与64较远 冲突概率比较低

class guest{
public:
    long long id;
    string name;
    int freq; //频率
    int dis; //里程
    
    guest(long long id, string name){
        this->id = id;
        this->name = name;
        freq = 0;
        dis = 0;
    }
    
    guest(){
        
    }
};
vector<long long> ids; //存储所有的身份证号 便于后续统计
int cnt = 0; //记录发生冲突的次数
int h[N], ne[N], idx = 0;
//h哈希表 ne为指向下一个节点的指针 idx表示当前可用的编号
guest e[N]; //存储客户信息

//插入哈希表函数
void insert(long long id, string name){
    int k = id % N;
    
    guest g(id, name);
    e[idx] = g;
    if (h[k] != -1) cnt++;
    ne[idx] = h[k];
    h[k] = idx;
    idx++;
}

//查找函数 其实是插入记录
void find(long long id, int dis){
    int k = id % N;
    
    for (int i = h[k]; i != -1; i = ne[i]){
        if (e[i].id == id){
            e[i].freq += 1;
            e[i].dis += dis;
        }
    }
}

int main(){
    srand((unsigned int)time(NULL));
    
    //哈希表中全部初始化为空指针
    memset(h, -1, sizeof(h));
    
    //读入顾客信息 同时创建哈希表
    fstream f1;
    f1.open("顾客信息.txt", ios::in);
    if(!f1.is_open()){
        cout << "文件打开失败" << endl;
        exit(0);
    }
    for (int i = 0; i < 30; i++){
        long long id;
        f1 >> id;
        string name;
        f1 >> name;
        ids.push_back(id);
        insert(id, name);
    }
    
    //读入航班记录 更改哈希表
    fstream f2;
    f2.open("记录.txt", ios::in);
    if(!f2.is_open()){
        cout << "文件打开失败" << endl;
        exit(0);
    }
    for (int i = 0; i < 100; i++){
        long long id;
        f2 >> id;
        string name;
        f2 >> name;
        string code;
        f2 >> code;
        string date;
        f2 >> date;
        int dis;
        f2 >> dis;
        find(id, dis);
    }
    
    //实现统计功能
    cout << "拉链法哈希表发生冲突的次数为：" << cnt << endl;
    int maxFreq = 0;
    int maxFreqIdx = -1;
    int maxDis = 0;
    int maxDisIdx = -1;
    for (long long id : ids){
        int k = id % N;
        for (int i = h[k]; i != -1; i = ne[i]){
            if (e[i].id == id && e[i].freq > maxFreq){
                maxFreq = e[i].freq;
                maxFreqIdx = i;
            }
            if (e[i].id == id && e[i].dis > maxDis){
                maxDis = e[i].dis;
                maxDisIdx = i;
            }
        }
    }
    
    cout << "乘坐航班频率最高的顾客身份证和姓名为：" << endl;
    cout << e[maxFreqIdx].id << ' ' << e[maxFreqIdx].name << endl;
    cout << "乘坐航班里程数最大的顾客身份证和姓名为：" << endl;
    cout << e[maxDisIdx].id << ' ' << e[maxDisIdx].name << endl;
    
    return 0;
}
```

> 开放寻址法

```C++
#include<iostream>
#include<vector>
#include<string>
#include<fstream>
#include<cstring>
using namespace std;

const int N = 97; //开放寻址法的空间一般要开到原长的两到三倍 且要取一个里2的整次幂较远的质数

class guest{
public:
    long long id;
    string name;
    int freq; //频率
    int dis; //里程
    
    guest(long long id, string name){
        this->id = id;
        this->name = name;
        freq = 0;
        dis = 0;
    }
    
    guest(){
        id = -1;
        //默认初始化时将id初始化为-1 表示当前位没有存储客户信息
    }
};
vector<long long> ids; //存储所有的身份证号 便于后续统计
int cnt = 0; //记录发生冲突的次数
vector<int> times; //记录每一次发生冲突都发生了多少次重定位
guest h[N];
//h哈希表

//核心操作 查找 如果存在x 返回的是x的编号，如果不存在x 返回的是x应当存储的位置
//这种查找需要统计冲突
int find1(long long id){
    int k = id % N;
    int time = 0; //统计重定位的次数
    
    while (h[k].id != -1 && h[k].id != id){
        k++;
        time++;
        if (k == N) k = 0;
    }
    
    if (time){
        cnt++;
        times.push_back(time);
    }
    
    return k;
}

//这种查找不需要统计冲突
int find2(long long id){
    int k = id % N;
    
    while (h[k].id != -1 && h[k].id != id){
        k++;
        if (k == N) k = 0;
    }
    
    return k;
}

int main(){
    //读入顾客信息 同时创建哈希表
    fstream f1;
    f1.open("顾客信息.txt", ios::in);
    if(!f1.is_open()){
        cout << "文件打开失败" << endl;
        exit(0);
    }
    for (int i = 0; i < 30; i++){
        long long id;
        f1 >> id;
        string name;
        f1 >> name;
        ids.push_back(id);
        
        int k = find1(id);
        guest g(id, name);
        h[k] = g;
    }
    
    //读入航班记录 更改哈希表
    fstream f2;
    f2.open("记录.txt", ios::in);
    if(!f2.is_open()){
        cout << "文件打开失败" << endl;
        exit(0);
    }
    for (int i = 0; i < 100; i++){
        long long id;
        f2 >> id;
        string name;
        f2 >> name;
        string code;
        f2 >> code;
        string date;
        f2 >> date;
        int dis;
        f2 >> dis;
        
        int k = find2(id);
        h[k].freq++;
        h[k].dis += dis;
    }
    
    //实现统计功能
    cout << "开放寻址法哈希表发生冲突的次数为：" << cnt << endl;
    for (int i = 1; i <= cnt; i++){
        cout << "第" << i << "次冲突重定位的次数为：" << times[i - 1] << endl;
    }
    
    int maxFreq = 0;
    int maxFreqIdx = -1;
    int maxDis = 0;
    int maxDisIdx = -1;
    for (long long id : ids){
        int k = find2(id);
        if (h[k].freq > maxFreq){
            maxFreq = h[k].freq;
            maxFreqIdx = k;
        }
        if (h[k].dis > maxDis){
            maxDis = h[k].dis;
            maxDisIdx = k;
        }
    }
    
    cout << "乘坐航班频率最高的顾客身份证和姓名为：" << endl;
    cout << h[maxFreqIdx].id << ' ' << h[maxFreqIdx].name << endl;
    cout << "乘坐航班里程数最大的顾客身份证和姓名为：" << endl;
    cout << h[maxDisIdx].id << ' ' << h[maxDisIdx].name << endl;
    
    return 0;
}
```

#### 测试样例

本题的数据全部为自己随机

> 顾客信息.txt

![截屏2023-01-23 22.23.05](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-23 22.23.05.png)

共30条客户信息 从前到后分别为身份证 姓名

> 记录.txt

![截屏2023-01-23 22.23.55](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-23 22.23.55.png)

共100条航班记录 从前到后依次为身份证 姓名 航班号 日期 里程

两种方法的程序运行结果如下

> 拉链法

![截屏2023-01-23 22.25.31](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-23 22.25.31.png)

> 开放寻址法

![截屏2023-01-23 22.35.15](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-23 22.35.15.png)

经验证 根据建立的哈希表查找到的答案是正确的

#### 算法时间复杂度

由于使用了哈希表 查找是常数复杂度 总共的统计复杂度为`O(N)`

#### 代码行数

267

### 迷宫问题

#### 数据结构

```C++
const int N = 25, M = N * N;

typedef pair<int, int> PII;

int g[N][N]; //图
PII q[M]; //bfs队列
PII pre[N][N]; //存储前一个点 同时作为判断是否已经访问的标志
```

#### 算法设计思想

总体上采用了bfs的算法 直至队列为空 重复一下过程：

对于每个出队的元素 检查其上右下左四个方向的点是否满足以下三个要求

1. 是否在迷宫范围内
2. 是否未被访问
3. 是否是墙

如果都满足 则可以将其加入队列 并记录其前一点为当前点

#### 源代码

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<fstream>

#define x first
#define y second

using namespace std;

const int N = 25, M = N * N;

typedef pair<int, int> PII;

int g[N][N]; //图
PII q[M]; //bfs队列
PII pre[N][N]; //存储前一个点 同时作为判断是否已经访问的标志

void bfs(int sx, int sy){
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; //顺序为上右下左在x和y方向的偏移量
    
    int hh = 0, tt = -1;
    q[++tt] = {sx, sy}; //队列初始化 同时将起点先加入队列
    
    memset(pre, -1, sizeof(pre)); //初始化为不可能出现的数表示未被访问
    pre[sx][sy] = {0, 0}; //起点的前面随便初始化成不为{-1, -1}的对组即可表示起点已经被访问
    
    while (hh <= tt){
        PII t = q[hh++];
        
        for (int i = 0; i < 4; i++){
            int a = t.x + dx[i], b = t.y + dy[i];
            
            if (a < 0 || a >= N || b < 0 || b >= N) continue;
            if (g[a][b]) continue;
            if (pre[a][b].x != -1) continue;
            
            q[++tt] = {a, b};
            pre[a][b] = t; //记录新加入点的前一位
        }
    }
}

int main(){
    fstream f;
    f.open("迷宫样例.txt", ios::in);
    if (!f.is_open()){
        cout << "文件打开失败" << endl;
        exit(0);
    }
    int num1, num2;
    f >> num1 >> num2;
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            f >> g[i][j];
        }
    }
    
    cout << "请输入起点坐标" << endl;
    int stX, stY;
    cin >> stX >> stY;
    cout << "请输入终点坐标" << endl;
    int endX, endY;
    cin >> endX >> endY;
    
    bfs(endX, endY); //从终点往起点开始搜索 最终输出的结果就是正的
    
    PII end(stX, stY);
    
    while (1){
        //从起点往终点走
        g[end.x][end.y] = 6;
        
        if (end.x == endX && end.y == endY) break;
        end = pre[end.x][end.y];
    }
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            printf("%d ", g[i][j]);
            if (j == 24) puts("");
        }
    }
    
    return 0;
}
```

#### 测试样例

![截屏2023-01-26 09.41.40](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-26 09.41.40.png)

0表示可走 1表示墙 6表示路线 样例来自于老师发的迷宫样例.txt

#### 算法时间复杂度

基于bfs 复杂度为`O(n + m)`其中n为点数 m为边数

#### 代码行数

85

### 词梯

#### 数据结构

```C++
vector<string> words; //存储所有单词的字符串数组
map<string, int> wordToNum; //建立从单词到其编号的映射
const int N = 466550; //事先统计出的总单词个数 用于初始化
int q[N]; //bfs队列 存储编号
int pre[N]; //存储前一个单词的编号
```

#### 算法设计思想

总体采用了bfs的算法 直至队列为空 重复以下过程：
对每个出队单词 判断当前单词表中是否存在满足以下条件的单词：

1. 长度一致
2. 尚未被访问
3. 有且仅有一个字母不相同

若存在 则将找到的该单词入队 同时记录其前一个单词为出队单词

#### 源代码

```C++
#include<iostream>
#include<vector>
#include<string>
#include<map>
#include<fstream>
#include<algorithm>
using namespace std;

vector<string> words; //存储所有单词的字符串数组
map<string, int> wordToNum; //建立从单词到其编号的映射
const int N = 466550; //事先统计出的总单词个数 用于初始化
int q[N]; //bfs队列 存储编号
int pre[N]; //存储前一个单词的编号

void bfs(int u, int n){
    int hh = 0, tt = -1;
    q[++tt] = u;
    
    memset(pre, -1, sizeof(pre)); //-1表示未访问
    pre[u] = 0;
    
    while (hh <= tt){
        int t = q[hh++];
        
        for (int i = 0; i < n; i++){
            if (words[t].size() != words[i].size()) continue;
            if (pre[i] != -1) continue;
            int cnt = 0;
            for (int j = 0; j < words[t].size(); j++){
                if (words[t][j] != words[i][j]) cnt++;
                if (cnt > 1) break;
            }
            if (cnt > 1) continue;
            
            q[++tt] = i;
            pre[i] = t;
        }
    }
}

int main(){
    fstream f;
    f.open("words.txt", ios::in);
    if (!f.is_open()){
        cout << "文件打开失败" << endl;
        exit(0);
    }
    
    cout << "请输入起始单词" << endl;
    string startWord;
    cin >> startWord;
    cout << "请输入终止单词" << endl;
    string endWord;
    cin >> endWord;
    
    //提前输入单词 只将与目标单词长度一致的单词加入程序 以减少运行时间
    string word;
    int idx = 0;
    while (f >> word){
        if (word.size() == startWord.size()){
            words.push_back(word);
            wordToNum.insert(pair<string, int>{word, idx});
            idx ++;
        }
    }
    
    //找到对应编号
    int s = wordToNum[startWord];
    int e = wordToNum[endWord];
    
    bfs(e, idx); //从终点开始走 这样输出的时候就是正的 传入idx以表示当前单词数组中的单词数量 用于遍历

    int end = s;
    
    cout << "最短词梯如下：" << endl;
    
    //从起点往终点走
    while (true){
        if (end == e){
            cout << words[end] << endl;
            break;
        }
        else{
            cout << words[end] << "->";
            end = pre[end];
        }
    }

    return 0;
}
```

#### 测试样例

![截屏2023-01-26 09.51.27](/Users/plotnickslope/Library/Application Support/typora-user-images/截屏2023-01-26 09.51.27.png)

经与老师给出的样例进行比对 可判断结果正确

#### 算法时间复杂度

基于bfs 复杂度为`O(n + m)`其中n为点数 m为边数

#### 代码行数

90

## 总结

本次课程设计共计完成必做题6道 选做题15分 各题代码行数如下：

+ 菜鸟管理系统 528
+ 算数表达式求值 234
+ 特殊路径统计 122
+ 公交线路提示 341
+ 哈夫曼编码 286
+ 排序算法比较 301
+ 棋局评估 182
+ URL映射 89
+ 连连看 264
+ 电子小词典 240
+ 哈希表应用 267
+ 迷宫问题 85
+ 词梯 90

总代码行数 3029

## 心得体会

1. 数据结构只是编程中最基础的知识 编程真正的难点在于算法设计 作为一个转专业学生 从今往后需要努力学习算法 学习不同算法的思想后 将其复刻 形成模板 并灵活运用在各种题目中也很重要
2. 有不少的程序 前一段时间写 后一段时间写报告再看的时候 会发现不少问题 要么是处理数据的手法太幼稚太复杂 要么是程序本身存在一些特殊情况的漏洞 比如表达式求值中关于负数计算的问题 菜鸟管理系统部分功能尚未实现的问题等等 这表明自己的编程技术尚未熟练 除了平时的作业题之外 还需要多写一些项目来提升写项目的能力
3. 本次课设大部分程序写的很紧凑 不存在恶意空行以增加代码行数的行为 确实是自己一个一个字符努力的结果 希望老师能给个优秀！
